{
  "version": 3,
  "sources": ["../../shepherd.js/node_modules/deepmerge/dist/cjs.js", "../../shepherd.js/src/js/utils/type-check.js", "../../shepherd.js/src/js/evented.js", "../../shepherd.js/src/js/utils/auto-bind.js", "../../shepherd.js/src/js/utils/bind.js", "../../shepherd.js/src/js/utils/general.js", "../../shepherd.js/node_modules/@floating-ui/core/dist/floating-ui.core.esm.js", "../../shepherd.js/node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js", "../../shepherd.js/src/js/utils/floating-ui.js", "../../shepherd.js/node_modules/svelte/internal/index.mjs", "../../shepherd.js/src/js/components/shepherd-button.svelte", "../../shepherd.js/src/js/components/shepherd-footer.svelte", "../../shepherd.js/src/js/components/shepherd-cancel-icon.svelte", "../../shepherd.js/src/js/components/shepherd-title.svelte", "../../shepherd.js/src/js/components/shepherd-header.svelte", "../../shepherd.js/src/js/components/shepherd-text.svelte", "../../shepherd.js/src/js/components/shepherd-content.svelte", "../../shepherd.js/src/js/components/shepherd-element.svelte", "../../shepherd.js/src/js/step.js", "../../shepherd.js/src/js/utils/cleanup.js", "../../shepherd.js/src/js/utils/overlay-path.js", "../../shepherd.js/src/js/components/shepherd-modal.svelte", "../../shepherd.js/src/js/tour.js", "../../shepherd.js/src/js/shepherd.js"],
  "sourcesContent": ["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "/**\n * Checks if `value` is classified as an `Element`.\n * @param {*} value The param to check if it is an Element\n */\nexport function isElement(value) {\n  return value instanceof Element;\n}\n\n/**\n * Checks if `value` is classified as an `HTMLElement`.\n * @param {*} value The param to check if it is an HTMLElement\n */\nexport function isHTMLElement(value) {\n  return value instanceof HTMLElement;\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n * @param {*} value The param to check if it is a function\n */\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\n * Checks if `value` is classified as a `String` object.\n * @param {*} value The param to check if it is a string\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Checks if `value` is undefined.\n * @param {*} value The param to check if it is undefined\n */\nexport function isUndefined(value) {\n  return value === undefined;\n}\n", "import { isUndefined } from './utils/type-check';\n\nexport class Evented {\n  on(event, handler, ctx, once = false) {\n    if (isUndefined(this.bindings)) {\n      this.bindings = {};\n    }\n    if (isUndefined(this.bindings[event])) {\n      this.bindings[event] = [];\n    }\n    this.bindings[event].push({ handler, ctx, once });\n\n    return this;\n  }\n\n  once(event, handler, ctx) {\n    return this.on(event, handler, ctx, true);\n  }\n\n  off(event, handler) {\n    if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n      return this;\n    }\n\n    if (isUndefined(handler)) {\n      delete this.bindings[event];\n    } else {\n      this.bindings[event].forEach((binding, index) => {\n        if (binding.handler === handler) {\n          this.bindings[event].splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  trigger(event, ...args) {\n    if (!isUndefined(this.bindings) && this.bindings[event]) {\n      this.bindings[event].forEach((binding, index) => {\n        const { ctx, handler, once } = binding;\n\n        const context = ctx || this;\n\n        handler.apply(context, args);\n\n        if (once) {\n          this.bindings[event].splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n}\n", "/**\n * Binds all the methods on a JS Class to the `this` context of the class.\n * Adapted from https://github.com/sindresorhus/auto-bind\n * @param {object} self The `this` context of the class\n * @return {object} The `this` context of the class\n */\nexport default function autoBind(self) {\n  const keys = Object.getOwnPropertyNames(self.constructor.prototype);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const val = self[key];\n    if (key !== 'constructor' && typeof val === 'function') {\n      self[key] = val.bind(self);\n    }\n  }\n\n  return self;\n}\n", "import { isUndefined } from './type-check';\n\n/**\n * Sets up the handler to determine if we should advance the tour\n * @param {string} selector\n * @param {Step} step The step instance\n * @return {Function}\n * @private\n */\nfunction _setupAdvanceOnHandler(selector, step) {\n  return (event) => {\n    if (step.isOpen()) {\n      const targetIsEl = step.el && event.currentTarget === step.el;\n      const targetIsSelector =\n        !isUndefined(selector) && event.currentTarget.matches(selector);\n\n      if (targetIsSelector || targetIsEl) {\n        step.tour.next();\n      }\n    }\n  };\n}\n\n/**\n * Bind the event handler for advanceOn\n * @param {Step} step The step instance\n */\nexport function bindAdvance(step) {\n  // An empty selector matches the step element\n  const { event, selector } = step.options.advanceOn || {};\n  if (event) {\n    const handler = _setupAdvanceOnHandler(selector, step);\n\n    // TODO: this should also bind/unbind on show/hide\n    let el;\n    try {\n      el = document.querySelector(selector);\n    } catch (e) {\n      // TODO\n    }\n    if (!isUndefined(selector) && !el) {\n      return console.error(\n        `No element was found for the selector supplied to advanceOn: ${selector}`\n      );\n    } else if (el) {\n      el.addEventListener(event, handler);\n      step.on('destroy', () => {\n        return el.removeEventListener(event, handler);\n      });\n    } else {\n      document.body.addEventListener(event, handler, true);\n      step.on('destroy', () => {\n        return document.body.removeEventListener(event, handler, true);\n      });\n    }\n  } else {\n    return console.error(\n      'advanceOn was defined, but no event name was passed.'\n    );\n  }\n}\n", "import { isFunction, isString } from './type-check';\n\n/**\n * Ensure class prefix ends in `-`\n * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n * @return {string} The prefix ending in `-`\n */\nexport function normalizePrefix(prefix) {\n  if (!isString(prefix) || prefix === '') {\n    return '';\n  }\n\n  return prefix.charAt(prefix.length - 1) !== '-' ? `${prefix}-` : prefix;\n}\n\n/**\n * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n * @param {Step} step The step instance\n * @returns {{}|{element, on}}\n * `element` is a qualified HTML Element\n * `on` is a string position value\n */\nexport function parseAttachTo(step) {\n  const options = step.options.attachTo || {};\n  const returnOpts = Object.assign({}, options);\n\n  if (isFunction(returnOpts.element)) {\n    // Bind the callback to step so that it has access to the object, to enable running additional logic\n    returnOpts.element = returnOpts.element.call(step);\n  }\n\n  if (isString(returnOpts.element)) {\n    // Can't override the element in user opts reference because we can't\n    // guarantee that the element will exist in the future.\n    try {\n      returnOpts.element = document.querySelector(returnOpts.element);\n    } catch (e) {\n      // TODO\n    }\n    if (!returnOpts.element) {\n      console.error(\n        `The element for this Shepherd step was not found ${options.element}`\n      );\n    }\n  }\n\n  return returnOpts;\n}\n\n/**\n * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n * alternative for the deprecated step.isCentered() method.\n * @param resolvedAttachToOptions\n * @returns {boolean}\n */\nexport function shouldCenterStep(resolvedAttachToOptions) {\n  if (\n    resolvedAttachToOptions === undefined ||\n    resolvedAttachToOptions === null\n  ) {\n    return true;\n  }\n\n  return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n}\n\n/**\n * Create a unique id for steps, tours, modals, etc\n * @return {string}\n */\nexport function uuid() {\n  let d = Date.now();\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n", "function getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n    if (validMiddleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement` middleware', 'detected. This will lead to an infinite loop. Ensure only one of', 'either has been passed to the `middleware` array.'].join(' '));\n    }\n    if (!reference || !floating) {\n      console.error(['Floating UI: The reference and/or floating element was not defined', 'when `computePosition()` was called. Ensure that both elements have', 'been created and can be measured.'].join(' '));\n    }\n  }\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (process.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  if (process.env.NODE_ENV !== \"production\") ;\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = options || {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n});\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = options;\n      const {\n        rects\n      } = state;\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getSideObjectFromPadding(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nasync function convertValueToCoords(state, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(state) : value;\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(state) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const axis = getMainAxisFromPlacement(placement);\n      const isXAxis = axis === 'x';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isXAxis) {\n        availableWidth = min(\n        // Maximum clipping viewport width\n        width - overflow.right - overflow.left, overflowAvailableWidth);\n      } else {\n        availableHeight = min(\n        // Maximum clipping viewport height\n        height - overflow.bottom - overflow.top, overflowAvailableHeight);\n      }\n      if (!state.middlewareData.shift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isXAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try to use feature detection here instead.\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n  // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => {\n    // Add type check for old browsers.\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\n\n/**\n * Determines whether or not `.getBoundingClientRect()` is affected by visual\n * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the\n * visual viewport, while in other engines, they are values relative to the\n * layout viewport.\n */\nfunction isClientRectVisualViewportBased() {\n  // TODO: Try to use feature detection here instead. Feature detection for\n  // this can fail in various ways, making the userAgent check the most\n  // reliable:\n  // • Always-visible scrollbar or not\n  // • Width of <html>\n\n  // Is Safari.\n  return /^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // `getParentNode` will never return a `Document` due to the fallback\n    // check, so it's either the <html> or <body> element.\n    return parentNode.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isClientRectVisualViewportBased();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const mutableRect = {\n      ...clippingAncestor\n    };\n    if (isClientRectVisualViewportBased()) {\n      var _win$visualViewport, _win$visualViewport2;\n      const win = getWindow(element);\n      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;\n      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;\n    }\n    rect = mutableRect;\n  }\n  return rectToClientRect(rect);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldIgnoreCurrentNode = computedStyle.position === 'fixed';\n    if (shouldIgnoreCurrentNode) {\n      currentContainingBlockComputedStyle = null;\n    } else {\n      const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n      if (shouldDropCurrentNode) {\n        // Drop non-containing blocks.\n        result = result.filter(ancestor => ancestor !== currentNode);\n      } else {\n        // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n      }\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n  if (elementResize) {\n    observer = new ResizeObserver(() => {\n      update();\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, getOverflowAncestors, platform };\n", "import merge from 'deepmerge';\nimport { shouldCenterStep } from './general';\nimport {\n  autoUpdate,\n  arrow,\n  computePosition,\n  flip,\n  limitShift,\n  shift\n} from '@floating-ui/dom';\n\n/**\n * Floating UI Options\n *\n * @typedef {object} FloatingUIOptions\n */\n\n/**\n * Determines options for the tooltip and initializes event listeners.\n *\n * @param {Step} step The step instance\n *\n * @return {FloatingUIOptions}\n */\nexport function setupTooltip(step) {\n  if (step.cleanup) {\n    step.cleanup();\n  }\n\n  const attachToOptions = step._getResolvedAttachToOptions();\n\n  let target = attachToOptions.element;\n  const floatingUIOptions = getFloatingUIOptions(attachToOptions, step);\n  const shouldCenter = shouldCenterStep(attachToOptions);\n\n  if (shouldCenter) {\n    target = document.body;\n    const content = step.shepherdElementComponent.getElement();\n    content.classList.add('shepherd-centered');\n  }\n\n  step.cleanup = autoUpdate(target, step.el, () => {\n    // The element might have already been removed by the end of the tour.\n    if (!step.el) {\n      step.cleanup();\n      return;\n    }\n\n    setPosition(target, step, floatingUIOptions, shouldCenter);\n  });\n\n  step.target = attachToOptions.element;\n\n  return floatingUIOptions;\n}\n\n/**\n * Merge tooltip options handling nested keys.\n *\n * @param tourOptions - The default tour options.\n * @param options - Step specific options.\n *\n * @return {floatingUIOptions: FloatingUIOptions}\n */\nexport function mergeTooltipConfig(tourOptions, options) {\n  return {\n    floatingUIOptions: merge(\n      tourOptions.floatingUIOptions || {},\n      options.floatingUIOptions || {}\n    )\n  };\n}\n\n/**\n * Cleanup function called when the step is closed/destroyed.\n *\n * @param {Step} step\n */\nexport function destroyTooltip(step) {\n  if (step.cleanup) {\n    step.cleanup();\n  }\n\n  step.cleanup = null;\n}\n\n/**\n *\n * @return {Promise<*>}\n */\nfunction setPosition(target, step, floatingUIOptions, shouldCenter) {\n  return (\n    computePosition(target, step.el, floatingUIOptions)\n      .then(floatingUIposition(step, shouldCenter))\n      // Wait before forcing focus.\n      .then(\n        (step) =>\n          new Promise((resolve) => {\n            setTimeout(() => resolve(step), 300);\n          })\n      )\n      // Replaces focusAfterRender modifier.\n      .then((step) => {\n        if (step && step.el) {\n          step.el.focus({ preventScroll: true });\n        }\n      })\n  );\n}\n\n/**\n *\n * @param step\n * @param shouldCenter\n * @return {function({x: *, y: *, placement: *, middlewareData: *}): Promise<unknown>}\n */\nfunction floatingUIposition(step, shouldCenter) {\n  return ({ x, y, placement, middlewareData }) => {\n    if (!step.el) {\n      return step;\n    }\n\n    if (shouldCenter) {\n      Object.assign(step.el.style, {\n        position: 'fixed',\n        left: '50%',\n        top: '50%',\n        transform: 'translate(-50%, -50%)'\n      });\n    } else {\n      Object.assign(step.el.style, {\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`\n      });\n    }\n\n    step.el.dataset.popperPlacement = placement;\n\n    placeArrow(step.el, middlewareData);\n\n    return step;\n  };\n}\n\n/**\n *\n * @param el\n * @param middlewareData\n */\nfunction placeArrow(el, middlewareData) {\n  const arrowEl = el.querySelector('.shepherd-arrow');\n  if (arrowEl && middlewareData.arrow) {\n    const { x: arrowX, y: arrowY } = middlewareData.arrow;\n    Object.assign(arrowEl.style, {\n      left: arrowX != null ? `${arrowX}px` : '',\n      top: arrowY != null ? `${arrowY}px` : ''\n    });\n  }\n}\n\n/**\n * Gets the `Floating UI` options from a set of base `attachTo` options\n * @param attachToOptions\n * @param {Step} step The step instance\n * @return {Object}\n * @private\n */\nexport function getFloatingUIOptions(attachToOptions, step) {\n  const options = {\n    strategy: 'absolute',\n    middleware: []\n  };\n\n  const arrowEl = addArrow(step);\n\n  const shouldCenter = shouldCenterStep(attachToOptions);\n\n  if (!shouldCenter) {\n    options.middleware.push(\n      flip(),\n      // Replicate PopperJS default behavior.\n      shift({\n        limiter: limitShift(),\n        crossAxis: true\n      })\n    );\n\n    if (arrowEl) {\n      options.middleware.push(arrow({ element: arrowEl }));\n    }\n\n    options.placement = attachToOptions.on;\n  }\n\n  return merge(step.options.floatingUIOptions || {}, options);\n}\n\n/**\n * @param {Step} step\n * @return {HTMLElement|false|null}\n */\nfunction addArrow(step) {\n  if (step.options.arrow && step.el) {\n    return step.el.querySelector('.shepherd-arrow');\n  }\n\n  return false;\n}\n", "function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.58.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n", "<script>\n  import { isFunction } from '../utils/type-check';\n\n  export let config, step;\n  let action, classes, disabled, label, secondary, text;\n\n  $: {\n    action = config.action ? config.action.bind(step.tour) : null;\n    classes = config.classes;\n    disabled = config.disabled ? getConfigOption(config.disabled) : false;\n    label = config.label ? getConfigOption(config.label) : null;\n    secondary = config.secondary;\n    text = config.text ? getConfigOption(config.text) : null;\n  }\n\n  function getConfigOption(option) {\n    if (isFunction(option)) {\n      return option = option.call(step);\n    }\n    return option;\n  }\n\n</script>\n\n<style global>\n  .shepherd-button {\n    background: rgb(50, 136, 230);\n    border: 0;\n    border-radius: 3px;\n    color: rgba(255, 255, 255, 0.75);\n    cursor: pointer;\n    margin-right: 0.5rem;\n    padding: 0.5rem 1.5rem;\n    transition: all 0.5s ease;\n  }\n\n  .shepherd-button:not(:disabled):hover {\n    background: rgb(25, 111, 204);\n    color: rgba(255, 255, 255, 0.75);\n  }\n\n  .shepherd-button.shepherd-button-secondary {\n    background: rgb(241, 242, 243);\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-button.shepherd-button-secondary:not(:disabled):hover {\n    background: rgb(214, 217, 219);\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-button:disabled {\n    cursor: not-allowed;\n  }\n</style>\n\n<button\n  aria-label=\"{label ? label : null}\"\n  class=\"{`${(classes || '')} shepherd-button ${(secondary ? 'shepherd-button-secondary' : '')}`}\"\n  disabled={disabled}\n  on:click={action}\n  tabindex=\"0\"\n>\n    {@html text}\n</button>\n", "<script>\n  import ShepherdButton from './shepherd-button.svelte';\n\n  export let step;\n\n  $: buttons = step.options.buttons;\n</script>\n\n<style global>\n  .shepherd-footer {\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px;\n    display: flex;\n    justify-content: flex-end;\n    padding: 0 0.75rem 0.75rem;\n  }\n\n  .shepherd-footer .shepherd-button:last-child {\n    margin-right: 0;\n  }\n</style>\n\n<footer class=\"shepherd-footer\">\n    {#if buttons}\n        {#each buttons as config}\n          <ShepherdButton\n            {config}\n            {step}\n          />\n        {/each}\n    {/if}\n</footer>\n", "<script>\n  export let cancelIcon, step;\n\n  /**\n   * Add a click listener to the cancel link that cancels the tour\n   */\n  const handleCancelClick = (e) => {\n    e.preventDefault();\n    step.cancel();\n  };\n</script>\n\n<style global>\n  .shepherd-cancel-icon {\n    background: transparent;\n    border: none;\n    color: rgba(128, 128, 128, 0.75);\n    font-size: 2em;\n    cursor: pointer;\n    font-weight: normal;\n    margin: 0;\n    padding: 0;\n    transition: color 0.5s ease;\n  }\n\n  .shepherd-cancel-icon:hover {\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-cancel-icon {\n    color: rgba(128, 128, 128, 0.75);\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-cancel-icon:hover {\n    color: rgba(0, 0, 0, 0.75);\n  }\n</style>\n\n<button\n  aria-label=\"{cancelIcon.label ? cancelIcon.label : 'Close Tour'}\"\n  class=\"shepherd-cancel-icon\"\n  on:click={handleCancelClick}\n  type=\"button\"\n>\n  <span aria-hidden=\"true\">&times;</span>\n</button>\n", "<script>\n  import { afterUpdate } from 'svelte';\n  import { isFunction } from '../utils/type-check';\n  \n  export let labelId, element, title;\n  \n  afterUpdate(() => {\n    if (isFunction(title)) {\n      title = title();\n    }\n    \n    element.innerHTML = title;\n  });\n</script>\n\n<style global>\n  .shepherd-title {\n    color: rgba(0, 0, 0, 0.75);\n    display: flex;\n    font-size: 1rem;\n    font-weight: normal;\n    flex: 1 0 auto;\n    margin: 0;\n    padding: 0;\n  }\n</style>\n\n<h3\n  bind:this={element}\n  id=\"{labelId}\"\n  class=\"shepherd-title\"\n>\n</h3>\n", "<script>\n  import ShepherdCancelIcon from './shepherd-cancel-icon.svelte';\n  import ShepherdTitle from './shepherd-title.svelte';\n\n  export let labelId, step;\n  let title, cancelIcon;\n\n  $: {\n      title = step.options.title;\n      cancelIcon = step.options.cancelIcon;\n  }\n</script>\n\n<style global>\n  .shepherd-header {\n    align-items: center;\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px;\n    display: flex;\n    justify-content: flex-end;\n    line-height: 2em;\n    padding: 0.75rem 0.75rem 0;\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-header {\n    background: #e6e6e6;\n    padding: 1em;\n  }\n</style>\n\n<header class=\"shepherd-header\">\n    {#if title}\n      <ShepherdTitle\n        {labelId}\n        {title}\n      />\n    {/if}\n\n    {#if cancelIcon && cancelIcon.enabled}\n      <ShepherdCancelIcon\n        {cancelIcon}\n        {step}\n      />\n    {/if}\n</header>\n", "<script>\n  import { afterUpdate } from 'svelte';\n  import { isHTMLElement, isFunction } from '../utils/type-check';\n\n  export let descriptionId, element, step;\n\n  afterUpdate(() => {\n    let { text } = step.options;\n\n    if (isFunction(text)) {\n      text = text.call(step);\n    }\n\n    if (isHTMLElement(text)) {\n      element.appendChild(text);\n    } else {\n      element.innerHTML = text;\n    }\n  });\n</script>\n\n<style global>\n  .shepherd-text {\n    color: rgba(0, 0, 0, 0.75);\n    font-size: 1rem;\n    line-height: 1.3em;\n    padding: 0.75em;\n  }\n\n  .shepherd-text p {\n    margin-top: 0;\n  }\n\n  .shepherd-text p:last-child {\n    margin-bottom: 0;\n  }\n</style>\n\n<div\n  bind:this={element}\n  class=\"shepherd-text\"\n  id=\"{descriptionId}\"\n>\n</div>\n\n", "<script>\n  import ShepherdFooter from './shepherd-footer.svelte';\n  import ShepherdHeader from './shepherd-header.svelte';\n  import ShepherdText from './shepherd-text.svelte';\n  import { isUndefined } from '../utils/type-check.js';\n\n  export let descriptionId, labelId, step;\n</script>\n\n<style global>\n  .shepherd-content {\n    border-radius: 5px;\n    outline: none;\n    padding: 0;\n  }\n</style>\n\n<div\n  class=\"shepherd-content\"\n>\n  {#if !isUndefined(step.options.title) || (step.options.cancelIcon && step.options.cancelIcon.enabled)}\n    <ShepherdHeader\n      {labelId}\n      {step}\n    />\n  {/if}\n\n  {#if !isUndefined(step.options.text)}\n    <ShepherdText\n      {descriptionId}\n      {step}\n    />\n  {/if}\n\n  {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n    <ShepherdFooter\n      {step}\n    />\n  {/if}\n</div>\n", "<script>\n  import { onMount, afterUpdate } from 'svelte';\n  import ShepherdContent from './shepherd-content.svelte';\n  import { isUndefined, isString } from '../utils/type-check.js';\n\n  const KEY_TAB = 9;\n  const KEY_ESC = 27;\n  const LEFT_ARROW = 37;\n  const RIGHT_ARROW = 39;\n\n  export let classPrefix, element, descriptionId, firstFocusableElement,\n    focusableElements, labelId, lastFocusableElement, step, dataStepId;\n\n  let hasCancelIcon, hasTitle, classes;\n\n  $: {\n    hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled;\n    hasTitle = step.options && step.options.title;\n  }\n\n  export const getElement = () => element;\n\n  onMount(() => {\n    // Get all elements that are focusable\n    dataStepId = { [`data-${classPrefix}shepherd-step-id`]: step.id };\n    focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]');\n    firstFocusableElement = focusableElements[0];\n    lastFocusableElement = focusableElements[focusableElements.length - 1];\n  });\n\n  afterUpdate(() => {\n    if(classes !== step.options.classes) {\n      updateDynamicClasses();\n    }\n  });\n\n  function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n  }\n\n  function removeClasses(classes) {\n    if (isString(classes)) {\n      const oldClasses = getClassesArray(classes);\n      if (oldClasses.length) {\n        element.classList.remove(...oldClasses);\n      }\n    }\n  }\n\n  function addClasses(classes) {\n    if(isString(classes)) {\n      const newClasses = getClassesArray(classes);\n      if (newClasses.length) {\n        element.classList.add(...newClasses);\n      }\n    }\n  }\n\n  function getClassesArray(classes) {\n     return classes.split(' ').filter(className => !!className.length);\n  }\n\n  /**\n   * Setup keydown events to allow closing the modal with ESC\n   *\n   * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n   *\n   * @private\n   */\n  const handleKeyDown = (e) => {\n    const { tour } = step;\n    switch (e.keyCode) {\n      case KEY_TAB:\n        if (focusableElements.length === 0) {\n          e.preventDefault();\n          break;\n        }\n        // Backward tab\n        if (e.shiftKey) {\n          if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n            e.preventDefault();\n            lastFocusableElement.focus();\n          }\n        } else {\n          if (document.activeElement === lastFocusableElement) {\n            e.preventDefault();\n            firstFocusableElement.focus();\n          }\n        }\n        break;\n      case KEY_ESC:\n        if (tour.options.exitOnEsc) {\n          step.cancel();\n        }\n        break;\n      case LEFT_ARROW:\n        if (tour.options.keyboardNavigation) {\n          tour.back();\n        }\n        break;\n      case RIGHT_ARROW:\n        if (tour.options.keyboardNavigation) {\n          tour.next();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n</script>\n\n<style global>\n  .shepherd-element {\n    background: #fff;\n    border-radius: 5px;\n    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);\n    max-width: 400px;\n    opacity: 0;\n    outline: none;\n    transition: opacity 0.3s, visibility 0.3s;\n    visibility: hidden;\n    width: 100%;\n    z-index: 9999;\n  }\n\n  .shepherd-enabled.shepherd-element {\n    opacity: 1;\n    visibility: visible;\n  }\n\n  .shepherd-element[data-popper-reference-hidden]:not(.shepherd-centered) {\n    opacity: 0;\n    pointer-events: none;\n    visibility: hidden;\n  }\n\n  .shepherd-element, .shepherd-element *,\n  .shepherd-element *:after,\n  .shepherd-element *:before {\n    box-sizing: border-box;\n  }\n\n  .shepherd-arrow,\n  .shepherd-arrow::before {\n    position: absolute;\n    width: 16px;\n    height: 16px;\n    z-index: -1;\n  }\n\n  .shepherd-arrow:before {\n    content: '';\n    transform: rotate(45deg);\n    background: #fff  ;\n  }\n\n  .shepherd-element[data-popper-placement^='top'] > .shepherd-arrow {\n    bottom: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='bottom'] > .shepherd-arrow {\n    top: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='left'] > .shepherd-arrow {\n    right: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='right'] > .shepherd-arrow {\n    left: -8px;\n  }\n\n  .shepherd-element.shepherd-centered > .shepherd-arrow {\n    opacity: 0;\n  }\n\n\n  /**\n  * Arrow on top of tooltip centered horizontally, with title color\n  */\n  .shepherd-element.shepherd-has-title[data-popper-placement^='bottom'] > .shepherd-arrow::before {\n    background-color: #e6e6e6;\n  }\n\n  .shepherd-target-click-disabled.shepherd-enabled.shepherd-target,\n  .shepherd-target-click-disabled.shepherd-enabled.shepherd-target * {\n    pointer-events: none;\n  }\n</style>\n\n<div\n  aria-describedby={!isUndefined(step.options.text) ? descriptionId : null}\n  aria-labelledby={step.options.title ? labelId : null}\n  bind:this={element}\n  class:shepherd-has-cancel-icon=\"{hasCancelIcon}\"\n  class:shepherd-has-title=\"{hasTitle}\"\n  class:shepherd-element=\"{true}\"\n  {...dataStepId}\n  on:keydown={handleKeyDown}\n  role=\"dialog\"\n  tabindex=\"0\"\n>\n    {#if step.options.arrow && step.options.attachTo && step.options.attachTo.element && step.options.attachTo.on}\n      <div class=\"shepherd-arrow\" data-popper-arrow></div>\n    {/if}\n  <ShepherdContent\n    {descriptionId}\n    {labelId}\n    {step}\n  />\n</div>\n", "import merge from 'deepmerge';\nimport { Evented } from './evented.js';\nimport autoBind from './utils/auto-bind.js';\nimport {\n  isElement,\n  isHTMLElement,\n  isFunction,\n  isUndefined\n} from './utils/type-check.js';\nimport { bindAdvance } from './utils/bind.js';\nimport { parseAttachTo, normalizePrefix, uuid } from './utils/general.js';\nimport {\n  setupTooltip,\n  destroyTooltip,\n  mergeTooltipConfig\n} from './utils/floating-ui.js';\nimport ShepherdElement from './components/shepherd-element.svelte';\n\n/**\n * A class representing steps to be added to a tour.\n * @extends {Evented}\n */\nexport class Step extends Evented {\n  /**\n   * Create a step\n   * @param {Tour} tour The tour for the step\n   * @param {object} options The options for the step\n   * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n   * @param {object} options.attachTo The element the step should be attached to on the page.\n   * An object with properties `element` and `on`.\n   *\n   * ```js\n   * const step = new Step(tour, {\n   *   attachTo: { element: '.some .selector-path', on: 'left' },\n   *   ...moreOptions\n   * });\n   * ```\n   *\n   * If you don’t specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n   * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n   * in the middle of the screen, without an arrow pointing to the target.\n   * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n   * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n   * @param {string} options.attachTo.on The optional direction to place the FloatingUI tooltip relative to the element.\n   *   - Possible string values: 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n   * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n   * It should be an object with a string `selector` and an `event` name\n   * ```js\n   * const step = new Step(tour, {\n   *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n   *   ...moreOptions\n   * });\n   * ```\n   * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n   * You can also always manually advance the Tour by calling `myTour.next()`.\n   * @param {function} options.beforeShowPromise A function that returns a promise.\n   * When the promise resolves, the rest of the `show` code for the step will execute.\n   * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n   * footer below the main body text.\n   * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n   * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n   * work inside the action.\n   * You can use action to skip steps or navigate to specific steps, with something like:\n   * ```js\n   * action() {\n   *   return this.show('some_step_name');\n   * }\n   * ```\n   * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n   * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n   * @param {string} options.buttons.button.label The aria-label text of the button\n   * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n   * @param {string} options.buttons.button.text The HTML text of the button\n   * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n   * @param {object} options.cancelIcon Options for the cancel icon\n   * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n   * @param {string} options.cancelIcon.label The label to add for `aria-label`\n   * @param {string} options.classes A string of extra classes to add to the step's content element.\n   * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n   * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n   * @param {string} options.id The string to use as the `id` for the step.\n   * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n   * @param {number | { topLeft: number, bottomLeft: number, bottomRight: number, topRight: number }} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n   * @param {object} options.floatingUIOptions Extra options to pass to FloatingUI\n   * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n   * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n   * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n   * define a custom action to do the scrolling, and possibly other logic.\n   * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n   * If it returns false, the step will be skipped.\n   * @param {string} options.text The text in the body of the step. It can be one of three types:\n   * ```\n   * - HTML string\n   * - `HTMLElement` object\n   * - `Function` to be executed when the step is built. It must return one the two options above.\n   * ```\n   * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n   * ```\n   * - HTML string\n   * - `Function` to be executed when the step is built. It must return HTML string.\n   * ```\n   * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n   * ```js\n   * when: {\n   *   show: function() {\n   *     window.scrollTo(0, 0);\n   *   }\n   * }\n   * ```\n   * @return {Step} The newly created Step instance\n   */\n  constructor(tour, options = {}) {\n    super(tour, options);\n    this.tour = tour;\n    this.classPrefix = this.tour.options\n      ? normalizePrefix(this.tour.options.classPrefix)\n      : '';\n    this.styles = tour.styles;\n\n    /**\n     * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n     * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n     * @type {null|{}|{element, to}}\n     * @private\n     */\n    this._resolvedAttachTo = null;\n\n    autoBind(this);\n\n    this._setOptions(options);\n\n    return this;\n  }\n\n  /**\n   * Cancel the tour\n   * Triggers the `cancel` event\n   */\n  cancel() {\n    this.tour.cancel();\n    this.trigger('cancel');\n  }\n\n  /**\n   * Complete the tour\n   * Triggers the `complete` event\n   */\n  complete() {\n    this.tour.complete();\n    this.trigger('complete');\n  }\n\n  /**\n   * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.\n   * Triggers `destroy` event\n   */\n  destroy() {\n    destroyTooltip(this);\n\n    if (isHTMLElement(this.el)) {\n      this.el.remove();\n      this.el = null;\n    }\n\n    this._updateStepTargetOnHide();\n\n    this.trigger('destroy');\n  }\n\n  /**\n   * Returns the tour for the step\n   * @return {Tour} The tour instance\n   */\n  getTour() {\n    return this.tour;\n  }\n\n  /**\n   * Hide the step\n   */\n  hide() {\n    this.tour.modal.hide();\n\n    this.trigger('before-hide');\n\n    if (this.el) {\n      this.el.hidden = true;\n    }\n\n    this._updateStepTargetOnHide();\n\n    this.trigger('hide');\n  }\n\n  /**\n   * Resolves attachTo options.\n   * @returns {{}|{element, on}}\n   * @private\n   */\n  _resolveAttachToOptions() {\n    this._resolvedAttachTo = parseAttachTo(this);\n    return this._resolvedAttachTo;\n  }\n\n  /**\n   * A selector for resolved attachTo options.\n   * @returns {{}|{element, on}}\n   * @private\n   */\n  _getResolvedAttachToOptions() {\n    if (this._resolvedAttachTo === null) {\n      return this._resolveAttachToOptions();\n    }\n\n    return this._resolvedAttachTo;\n  }\n\n  /**\n   * Check if the step is open and visible\n   * @return {boolean} True if the step is open and visible\n   */\n  isOpen() {\n    return Boolean(this.el && !this.el.hidden);\n  }\n\n  /**\n   * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n   * @return {*|Promise}\n   */\n  show() {\n    if (isFunction(this.options.beforeShowPromise)) {\n      return Promise.resolve(this.options.beforeShowPromise()).then(() =>\n        this._show()\n      );\n    }\n    return Promise.resolve(this._show());\n  }\n\n  /**\n   * Updates the options of the step.\n   *\n   * @param {Object} options The options for the step\n   */\n  updateStepOptions(options) {\n    Object.assign(this.options, options);\n\n    if (this.shepherdElementComponent) {\n      this.shepherdElementComponent.$set({ step: this });\n    }\n  }\n\n  /**\n   * Returns the element for the step\n   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n   */\n  getElement() {\n    return this.el;\n  }\n\n  /**\n   * Returns the target for the step\n   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n   */\n  getTarget() {\n    return this.target;\n  }\n\n  /**\n   * Creates Shepherd element for step based on options\n   *\n   * @return {Element} The DOM element for the step tooltip\n   * @private\n   */\n  _createTooltipContent() {\n    const descriptionId = `${this.id}-description`;\n    const labelId = `${this.id}-label`;\n\n    this.shepherdElementComponent = new ShepherdElement({\n      target: this.tour.options.stepsContainer || document.body,\n      props: {\n        classPrefix: this.classPrefix,\n        descriptionId,\n        labelId,\n        step: this,\n        styles: this.styles\n      }\n    });\n\n    return this.shepherdElementComponent.getElement();\n  }\n\n  /**\n   * If a custom scrollToHandler is defined, call that, otherwise do the generic\n   * scrollIntoView call.\n   *\n   * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n   * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n   * @private\n   */\n  _scrollTo(scrollToOptions) {\n    const { element } = this._getResolvedAttachToOptions();\n\n    if (isFunction(this.options.scrollToHandler)) {\n      this.options.scrollToHandler(element);\n    } else if (\n      isElement(element) &&\n      typeof element.scrollIntoView === 'function'\n    ) {\n      element.scrollIntoView(scrollToOptions);\n    }\n  }\n\n  /**\n   * _getClassOptions gets all possible classes for the step\n   * @param {Object} stepOptions The step specific options\n   * @returns {String} unique string from array of classes\n   * @private\n   */\n  _getClassOptions(stepOptions) {\n    const defaultStepOptions =\n      this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n    const stepClasses = stepOptions.classes ? stepOptions.classes : '';\n    const defaultStepOptionsClasses =\n      defaultStepOptions && defaultStepOptions.classes\n        ? defaultStepOptions.classes\n        : '';\n    const allClasses = [\n      ...stepClasses.split(' '),\n      ...defaultStepOptionsClasses.split(' ')\n    ];\n    const uniqClasses = new Set(allClasses);\n\n    return Array.from(uniqClasses).join(' ').trim();\n  }\n\n  /**\n   * Sets the options for the step, maps `when` to events, sets up buttons\n   * @param {Object} options The options for the step\n   * @private\n   */\n  _setOptions(options = {}) {\n    let tourOptions =\n      this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n\n    tourOptions = merge({}, tourOptions || {});\n\n    this.options = Object.assign(\n      {\n        arrow: true\n      },\n      tourOptions,\n      options,\n      mergeTooltipConfig(tourOptions, options)\n    );\n\n    const { when } = this.options;\n\n    this.options.classes = this._getClassOptions(options);\n\n    this.destroy();\n    this.id = this.options.id || `step-${uuid()}`;\n\n    if (when) {\n      Object.keys(when).forEach((event) => {\n        this.on(event, when[event], this);\n      });\n    }\n  }\n\n  /**\n   * Create the element and set up the FloatingUI instance\n   * @private\n   */\n  _setupElements() {\n    if (!isUndefined(this.el)) {\n      this.destroy();\n    }\n\n    this.el = this._createTooltipContent();\n\n    if (this.options.advanceOn) {\n      bindAdvance(this);\n    }\n\n    // The tooltip implementation details are handled outside of the Step\n    // object.\n    setupTooltip(this);\n  }\n\n  /**\n   * Triggers `before-show`, generates the tooltip DOM content,\n   * sets up a FloatingUI instance for the tooltip, then triggers `show`.\n   * @private\n   */\n  _show() {\n    this.trigger('before-show');\n\n    // Force resolve to make sure the options are updated on subsequent shows.\n    this._resolveAttachToOptions();\n    this._setupElements();\n\n    if (!this.tour.modal) {\n      this.tour._setupModal();\n    }\n\n    this.tour.modal.setupForStep(this);\n    this._styleTargetElementForStep(this);\n    this.el.hidden = false;\n\n    // start scrolling to target before showing the step\n    if (this.options.scrollTo) {\n      setTimeout(() => {\n        this._scrollTo(this.options.scrollTo);\n      });\n    }\n\n    this.el.hidden = false;\n\n    const content = this.shepherdElementComponent.getElement();\n    const target = this.target || document.body;\n    target.classList.add(`${this.classPrefix}shepherd-enabled`);\n    target.classList.add(`${this.classPrefix}shepherd-target`);\n    content.classList.add('shepherd-enabled');\n\n    this.trigger('show');\n  }\n\n  /**\n   * Modulates the styles of the passed step's target element, based on the step's options and\n   * the tour's `modal` option, to visually emphasize the element\n   *\n   * @param step The step object that attaches to the element\n   * @private\n   */\n  _styleTargetElementForStep(step) {\n    const targetElement = step.target;\n\n    if (!targetElement) {\n      return;\n    }\n\n    if (step.options.highlightClass) {\n      targetElement.classList.add(step.options.highlightClass);\n    }\n\n    targetElement.classList.remove('shepherd-target-click-disabled');\n\n    if (step.options.canClickTarget === false) {\n      targetElement.classList.add('shepherd-target-click-disabled');\n    }\n  }\n\n  /**\n   * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n   * and 'shepherd-target' classes\n   * @private\n   */\n  _updateStepTargetOnHide() {\n    const target = this.target || document.body;\n\n    if (this.options.highlightClass) {\n      target.classList.remove(this.options.highlightClass);\n    }\n\n    target.classList.remove(\n      'shepherd-target-click-disabled',\n      `${this.classPrefix}shepherd-enabled`,\n      `${this.classPrefix}shepherd-target`\n    );\n  }\n}\n", "/**\n * Cleanup the steps and set pointerEvents back to 'auto'\n * @param tour The tour object\n */\nexport function cleanupSteps(tour) {\n  if (tour) {\n    const { steps } = tour;\n\n    steps.forEach((step) => {\n      if (\n        step.options &&\n        step.options.canClickTarget === false &&\n        step.options.attachTo\n      ) {\n        if (step.target instanceof HTMLElement) {\n          step.target.classList.remove('shepherd-target-click-disabled');\n        }\n      }\n    });\n  }\n}\n", "/**\n * Generates the svg path data for a rounded rectangle overlay\n * @param {Object} dimension - Dimensions of rectangle.\n * @param {number} width - Width.\n * @param {number} height - Height.\n * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n * @param {number | { topLeft: number, topRight: number, bottomRight: number, bottomLeft: number }} [r=0] - Corner Radius. Keep this smaller than half of width or height.\n * @returns {string} - Rounded rectangle overlay path data.\n */\nexport function makeOverlayPath({ width, height, x = 0, y = 0, r = 0 }) {\n  const { innerWidth: w, innerHeight: h } = window;\n  const {\n    topLeft = 0,\n    topRight = 0,\n    bottomRight = 0,\n    bottomLeft = 0\n  } = typeof r === 'number'\n    ? { topLeft: r, topRight: r, bottomRight: r, bottomLeft: r }\n    : r;\n\n  return `M${w},${h}\\\nH0\\\nV0\\\nH${w}\\\nV${h}\\\nZ\\\nM${x + topLeft},${y}\\\na${topLeft},${topLeft},0,0,0-${topLeft},${topLeft}\\\nV${height + y - bottomLeft}\\\na${bottomLeft},${bottomLeft},0,0,0,${bottomLeft},${bottomLeft}\\\nH${width + x - bottomRight}\\\na${bottomRight},${bottomRight},0,0,0,${bottomRight}-${bottomRight}\\\nV${y + topRight}\\\na${topRight},${topRight},0,0,0-${topRight}-${topRight}\\\nZ`;\n}\n", "<script>\n  import { uuid } from '../utils/general.js';\n  import { makeOverlayPath } from '../utils/overlay-path.js';\n\n  export let element, openingProperties;\n  const guid = uuid();\n  let modalIsVisible = false;\n  let rafId = undefined;\n  let pathDefinition;\n\n  $: pathDefinition = makeOverlayPath(openingProperties);\n\n  closeModalOpening();\n\n  export const getElement = () => element;\n\n  export function closeModalOpening() {\n    openingProperties = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0,\n      r: 0\n    };\n  }\n\n  /**\n   * Hide the modal overlay\n   */\n  export function hide() {\n    modalIsVisible = false;\n\n    // Ensure we cleanup all event listeners when we hide the modal\n    _cleanupStepEventListeners();\n  }\n\n  /**\n   * Uses the bounds of the element we want the opening overtop of to set the dimensions of the opening and position it\n   * @param {Number} modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n   * @param {Number | { topLeft: Number, bottomLeft: Number, bottomRight: Number, topRight: Number }} modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n   * @param {HTMLElement} scrollParent The scrollable parent of the target element\n   * @param {HTMLElement} targetElement The element the opening will expose\n   */\n  export function positionModal(\n    modalOverlayOpeningPadding = 0,\n    modalOverlayOpeningRadius = 0,\n    scrollParent,\n    targetElement\n  ) {\n    if (targetElement) {\n      const { y, height } = _getVisibleHeight(targetElement, scrollParent);\n      const { x, width, left } = targetElement.getBoundingClientRect();\n\n      // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n      openingProperties = {\n        width: width + modalOverlayOpeningPadding * 2,\n        height: height + modalOverlayOpeningPadding * 2,\n        x: (x || left) - modalOverlayOpeningPadding,\n        y: y - modalOverlayOpeningPadding,\n        r: modalOverlayOpeningRadius\n      };\n    } else {\n      closeModalOpening();\n    }\n  }\n\n  /**\n   * If modal is enabled, setup the svg mask opening and modal overlay for the step\n   * @param {Step} step The step instance\n   */\n  export function setupForStep(step) {\n    // Ensure we move listeners from the previous step, before we setup new ones\n    _cleanupStepEventListeners();\n\n    if (step.tour.options.useModalOverlay) {\n      _styleForStep(step);\n      show();\n    } else {\n      hide();\n    }\n  }\n\n  /**\n   * Show the modal overlay\n   */\n  export function show() {\n    modalIsVisible = true;\n  }\n\n  const _preventModalBodyTouch = (e) => {\n    e.preventDefault();\n  };\n\n  const _preventModalOverlayTouch = (e) => {\n    e.stopPropagation();\n  };\n\n  /**\n   * Add touchmove event listener\n   * @private\n   */\n  function _addStepEventListeners() {\n    // Prevents window from moving on touch.\n    window.addEventListener('touchmove', _preventModalBodyTouch, {\n      passive: false\n    });\n  }\n\n  /**\n   * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n   * @private\n   */\n  function _cleanupStepEventListeners() {\n    if (rafId) {\n      cancelAnimationFrame(rafId);\n      rafId = undefined;\n    }\n\n    window.removeEventListener('touchmove', _preventModalBodyTouch, {\n      passive: false\n    });\n  }\n\n  /**\n   * Style the modal for the step\n   * @param {Step} step The step to style the opening for\n   * @private\n   */\n  function _styleForStep(step) {\n    const {\n      modalOverlayOpeningPadding,\n      modalOverlayOpeningRadius\n    } = step.options;\n\n    const scrollParent = _getScrollParent(step.target);\n\n    // Setup recursive function to call requestAnimationFrame to update the modal opening position\n    const rafLoop = () => {\n      rafId = undefined;\n      positionModal(\n        modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius,\n        scrollParent,\n        step.target\n      );\n      rafId = requestAnimationFrame(rafLoop);\n    };\n\n    rafLoop();\n\n    _addStepEventListeners();\n  }\n\n  /**\n   * Find the closest scrollable parent element\n   * @param {HTMLElement} element The target element\n   * @returns {HTMLElement}\n   * @private\n   */\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n\n    const isHtmlElement = element instanceof HTMLElement;\n    const overflowY =\n      isHtmlElement && window.getComputedStyle(element).overflowY;\n    const isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n\n    return _getScrollParent(element.parentElement);\n  }\n\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n  function _getVisibleHeight(element, scrollParent) {\n    const elementRect = element.getBoundingClientRect();\n    let top = elementRect.y || elementRect.top;\n    let bottom = elementRect.bottom || top + elementRect.height;\n\n    if (scrollParent) {\n      const scrollRect = scrollParent.getBoundingClientRect();\n      const scrollTop = scrollRect.y || scrollRect.top;\n      const scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n\n    const height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return { y: top, height };\n  }\n</script>\n\n<svg\n  bind:this={element}\n  class={`${\n    modalIsVisible ? 'shepherd-modal-is-visible' : ''\n  } shepherd-modal-overlay-container`}\n  on:touchmove={_preventModalOverlayTouch}\n>\n  <path d={pathDefinition} />\n</svg>\n\n<style global>\n  .shepherd-modal-overlay-container {\n    height: 0;\n    left: 0;\n    opacity: 0;\n    overflow: hidden;\n    pointer-events: none;\n    position: fixed;\n    top: 0;\n    transition: all 0.3s ease-out, height 0ms 0.3s, opacity 0.3s 0ms;\n    width: 100vw;\n    z-index: 9997;\n  }\n\n  .shepherd-modal-overlay-container.shepherd-modal-is-visible {\n    height: 100vh;\n    opacity: 0.5;\n    transition: all 0.3s ease-out, height 0s 0s, opacity 0.3s 0s;\n    transform: translateZ(0);\n  }\n\n  .shepherd-modal-overlay-container.shepherd-modal-is-visible path {\n    pointer-events: all;\n  }\n</style>\n", "import { Evented } from './evented.js';\nimport { Step } from './step.js';\nimport autoBind from './utils/auto-bind.js';\nimport {\n  isHTMLElement,\n  isFunction,\n  isString,\n  isUndefined\n} from './utils/type-check.js';\nimport { cleanupSteps } from './utils/cleanup.js';\nimport { normalizePrefix, uuid } from './utils/general.js';\nimport ShepherdModal from './components/shepherd-modal.svelte';\n\nconst Shepherd = new Evented();\n\n/**\n * Class representing the site tour\n * @extends {Evented}\n */\nexport class Tour extends Evented {\n  /**\n   * @param {Object} options The options for the tour\n   * @param {boolean | function(): boolean | Promise<boolean> | function(): Promise<boolean>} options.confirmCancel If true, will issue a `window.confirm` before cancelling.\n   * If it is a function(support Async Function), it will be called and wait for the return value, and will only be cancelled if the value returned is true\n   * @param {string} options.confirmCancelMessage The message to display in the `window.confirm` dialog\n   * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n   * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n   * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n   * set to false.\n   * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n   * unless this is explicitly set to false.\n   * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n   * If not set, the steps will be appended to `document.body`.\n   * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n   * If not set, the modal will be appended to `document.body`.\n   * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n   * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n   * dynamically generated `id` property.\n   * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n   * modal overlay. If true, the overlay will create an opening around the target element so that it\n   * can remain interactive\n   * @returns {Tour}\n   */\n  constructor(options = {}) {\n    super(options);\n\n    autoBind(this);\n\n    const defaultTourOptions = {\n      exitOnEsc: true,\n      keyboardNavigation: true\n    };\n\n    this.options = Object.assign({}, defaultTourOptions, options);\n    this.classPrefix = normalizePrefix(this.options.classPrefix);\n    this.steps = [];\n    this.addSteps(this.options.steps);\n\n    // Pass these events onto the global Shepherd object\n    const events = [\n      'active',\n      'cancel',\n      'complete',\n      'inactive',\n      'show',\n      'start'\n    ];\n    events.map((event) => {\n      ((e) => {\n        this.on(e, (opts) => {\n          opts = opts || {};\n          opts.tour = this;\n          Shepherd.trigger(e, opts);\n        });\n      })(event);\n    });\n\n    this._setTourID();\n\n    return this;\n  }\n\n  /**\n   * Adds a new step to the tour\n   * @param {Object|Step} options An object containing step options or a Step instance\n   * @param {number} index The optional index to insert the step at. If undefined, the step\n   * is added to the end of the array.\n   * @return {Step} The newly added step\n   */\n  addStep(options, index) {\n    let step = options;\n\n    if (!(step instanceof Step)) {\n      step = new Step(this, step);\n    } else {\n      step.tour = this;\n    }\n\n    if (!isUndefined(index)) {\n      this.steps.splice(index, 0, step);\n    } else {\n      this.steps.push(step);\n    }\n\n    return step;\n  }\n\n  /**\n   * Add multiple steps to the tour\n   * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n   */\n  addSteps(steps) {\n    if (Array.isArray(steps)) {\n      steps.forEach((step) => {\n        this.addStep(step);\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Go to the previous step in the tour\n   */\n  back() {\n    const index = this.steps.indexOf(this.currentStep);\n    this.show(index - 1, false);\n  }\n\n  /**\n   * Calls _done() triggering the 'cancel' event\n   * If `confirmCancel` is true, will show a window.confirm before cancelling\n   * If `confirmCancel` is a function, will call it and wait for the return value,\n   * and only cancel when the value returned is true\n   */\n  async cancel() {\n    if (this.options.confirmCancel) {\n      const confirmCancelIsFunction =\n        typeof this.options.confirmCancel === 'function';\n      const cancelMessage =\n        this.options.confirmCancelMessage ||\n        'Are you sure you want to stop the tour?';\n      const stopTour = confirmCancelIsFunction\n        ? await this.options.confirmCancel()\n        : window.confirm(cancelMessage);\n      if (stopTour) {\n        this._done('cancel');\n      }\n    } else {\n      this._done('cancel');\n    }\n  }\n\n  /**\n   * Calls _done() triggering the `complete` event\n   */\n  complete() {\n    this._done('complete');\n  }\n\n  /**\n   * Gets the step from a given id\n   * @param {Number|String} id The id of the step to retrieve\n   * @return {Step} The step corresponding to the `id`\n   */\n  getById(id) {\n    return this.steps.find((step) => {\n      return step.id === id;\n    });\n  }\n\n  /**\n   * Gets the current step\n   * @returns {Step|null}\n   */\n  getCurrentStep() {\n    return this.currentStep;\n  }\n\n  /**\n   * Hide the current step\n   */\n  hide() {\n    const currentStep = this.getCurrentStep();\n\n    if (currentStep) {\n      return currentStep.hide();\n    }\n  }\n\n  /**\n   * Check if the tour is active\n   * @return {boolean}\n   */\n  isActive() {\n    return Shepherd.activeTour === this;\n  }\n\n  /**\n   * Go to the next step in the tour\n   * If we are at the end, call `complete`\n   */\n  next() {\n    const index = this.steps.indexOf(this.currentStep);\n\n    if (index === this.steps.length - 1) {\n      this.complete();\n    } else {\n      this.show(index + 1, true);\n    }\n  }\n\n  /**\n   * Removes the step from the tour\n   * @param {String} name The id for the step to remove\n   */\n  removeStep(name) {\n    const current = this.getCurrentStep();\n\n    // Find the step, destroy it and remove it from this.steps\n    this.steps.some((step, i) => {\n      if (step.id === name) {\n        if (step.isOpen()) {\n          step.hide();\n        }\n\n        step.destroy();\n        this.steps.splice(i, 1);\n\n        return true;\n      }\n    });\n\n    if (current && current.id === name) {\n      this.currentStep = undefined;\n\n      // If we have steps left, show the first one, otherwise just cancel the tour\n      this.steps.length ? this.show(0) : this.cancel();\n    }\n  }\n\n  /**\n   * Show a specific step in the tour\n   * @param {Number|String} key The key to look up the step by\n   * @param {Boolean} forward True if we are going forward, false if backward\n   */\n  show(key = 0, forward = true) {\n    const step = isString(key) ? this.getById(key) : this.steps[key];\n\n    if (step) {\n      this._updateStateBeforeShow();\n\n      const shouldSkipStep =\n        isFunction(step.options.showOn) && !step.options.showOn();\n\n      // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n      if (shouldSkipStep) {\n        this._skipStep(step, forward);\n      } else {\n        this.trigger('show', {\n          step,\n          previous: this.currentStep\n        });\n\n        this.currentStep = step;\n        step.show();\n      }\n    }\n  }\n\n  /**\n   * Start the tour\n   */\n  start() {\n    this.trigger('start');\n\n    // Save the focused element before the tour opens\n    this.focusedElBeforeOpen = document.activeElement;\n\n    this.currentStep = null;\n\n    this._setupModal();\n\n    this._setupActiveTour();\n    this.next();\n  }\n\n  /**\n   * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n   * @param {String} event The event name to trigger\n   * @private\n   */\n  _done(event) {\n    const index = this.steps.indexOf(this.currentStep);\n    if (Array.isArray(this.steps)) {\n      this.steps.forEach((step) => step.destroy());\n    }\n\n    cleanupSteps(this);\n\n    this.trigger(event, { index });\n\n    Shepherd.activeTour = null;\n    this.trigger('inactive', { tour: this });\n\n    if (this.modal) {\n      this.modal.hide();\n    }\n\n    if (event === 'cancel' || event === 'complete') {\n      if (this.modal) {\n        const modalContainer = document.querySelector(\n          '.shepherd-modal-overlay-container'\n        );\n\n        if (modalContainer) {\n          modalContainer.remove();\n        }\n      }\n    }\n\n    // Focus the element that was focused before the tour started\n    if (isHTMLElement(this.focusedElBeforeOpen)) {\n      this.focusedElBeforeOpen.focus();\n    }\n  }\n\n  /**\n   * Make this tour \"active\"\n   * @private\n   */\n  _setupActiveTour() {\n    this.trigger('active', { tour: this });\n\n    Shepherd.activeTour = this;\n  }\n\n  /**\n   * _setupModal create the modal container and instance\n   * @private\n   */\n  _setupModal() {\n    this.modal = new ShepherdModal({\n      target: this.options.modalContainer || document.body,\n      props: {\n        classPrefix: this.classPrefix,\n        styles: this.styles\n      }\n    });\n  }\n\n  /**\n   * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n   * @param {Step} step The step to skip\n   * @param {Boolean} forward True if we are going forward, false if backward\n   * @private\n   */\n  _skipStep(step, forward) {\n    const index = this.steps.indexOf(step);\n\n    if (index === this.steps.length - 1) {\n      this.complete();\n    } else {\n      const nextIndex = forward ? index + 1 : index - 1;\n      this.show(nextIndex, forward);\n    }\n  }\n\n  /**\n   * Before showing, hide the current step and if the tour is not\n   * already active, call `this._setupActiveTour`.\n   * @private\n   */\n  _updateStateBeforeShow() {\n    if (this.currentStep) {\n      this.currentStep.hide();\n    }\n\n    if (!this.isActive()) {\n      this._setupActiveTour();\n    }\n  }\n\n  /**\n   * Sets this.id to `${tourName}--${uuid}`\n   * @private\n   */\n  _setTourID() {\n    const tourName = this.options.tourName || 'tour';\n\n    this.id = `${tourName}--${uuid()}`;\n  }\n}\n\nexport { Shepherd };\n", "import { Step } from './step.js';\nimport { Shepherd, Tour } from './tour.js';\n\nconst isServerSide = typeof window === 'undefined';\n\nclass NoOp {\n  constructor() {}\n}\n\nif (isServerSide) {\n  Object.assign(Shepherd, { Tour: NoOp, Step: NoOp });\n} else {\n  Object.assign(Shepherd, { Tour, Step });\n}\n\nexport default Shepherd;\n"],
  "mappings": "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",
  "names": ["isMergeableObject", "value", "isNonNullObject", "isSpecial", "stringValue", "Object", "prototype", "toString", "call", "isReactElement", "canUseSymbol", "Symbol", "for", "REACT_ELEMENT_TYPE", "$$typeof", "emptyTarget", "val", "Array", "isArray", "cloneUnlessOtherwiseSpecified", "options", "clone", "deepmerge", "defaultArrayMerge", "target", "source", "concat", "map", "element", "getMergeFunction", "key", "customMerge", "getEnumerableOwnPropertySymbols", "getOwnPropertySymbols", "filter", "symbol", "propertyIsEnumerable", "getKeys", "keys", "propertyIsOnObject", "object", "property", "_", "propertyIsUnsafe", "hasOwnProperty", "mergeObject", "destination", "forEach", "arrayMerge", "sourceIsArray", "targetIsArray", "sourceAndTargetTypesMatch", "all", "deepmergeAll", "array", "Error", "reduce", "prev", "next", "deepmerge_1", "cjs", "isElement", "Element", "isHTMLElement", "HTMLElement", "isFunction", "isString", "isUndefined", "undefined", "Evented", "on", "event", "handler", "ctx", "once", "bindings", "push", "off", "binding", "index", "splice", "trigger", "_len", "arguments", "length", "args", "_key", "context", "apply", "autoBind", "self", "getOwnPropertyNames", "constructor", "i", "bind", "_setupAdvanceOnHandler", "selector", "step", "isOpen", "targetIsEl", "el", "currentTarget", "targetIsSelector", "matches", "tour", "bindAdvance", "advanceOn", "document", "querySelector", "e", "console", "error", "addEventListener", "removeEventListener", "body", "normalizePrefix", "prefix", "charAt", "parseAttachTo", "attachTo", "returnOpts", "assign", "shouldCenterStep", "resolvedAttachToOptions", "uuid", "d", "Date", "now", "replace", "c", "r", "Math", "random", "floor", "getAlignment", "placement", "split", "getLengthFromAxis", "axis", "getSide", "getMainAxisFromPlacement", "includes", "computeCoordsFromPlacement", "_ref", "rtl", "reference", "floating", "commonX", "x", "width", "commonY", "y", "height", "mainAxis", "commonAlign", "side", "isVertical", "coords", "computePosition", "config", "strategy", "middleware", "platform", "validMiddleware", "Boolean", "isRTL", "rects", "getElementRects", "statefulPlacement", "middlewareData", "resetCount", "name", "fn", "nextX", "nextY", "data", "reset", "initialPlacement", "elements", "_extends", "expandPaddingObject", "padding", "top", "right", "bottom", "left", "getSideObjectFromPadding", "rectToClientRect", "rect", "detectOverflow", "state", "_await$platform$isEle", "boundary", "rootBoundary", "elementContext", "altBoundary", "paddingObject", "altContext", "clippingClientRect", "getClippingRect", "contextElement", "getDocumentElement", "offsetParent", "getOffsetParent", "offsetScale", "getScale", "elementClientRect", "convertOffsetParentRelativeRectToViewportRelativeRect", "min", "max", "within", "min$1", "max$1", "arrow", "arrowDimensions", "getDimensions", "isYAxis", "minProp", "maxProp", "clientProp", "endDiff", "startDiff", "arrowOffsetParent", "clientSize", "centerToReference", "center", "offset", "shouldAddOffset", "alignmentOffset", "centerOffset", "oppositeSideMap", "getOppositePlacement", "getAlignmentSides", "alignment", "mainAlignmentSide", "main", "cross", "oppositeAlignmentMap", "start", "end", "getOppositeAlignmentPlacement", "getExpandedPlacements", "oppositePlacement", "getSideList", "isStart", "lr", "rl", "tb", "bt", "getOppositeAxisPlacements", "flipAlignment", "direction", "list", "flip", "_middlewareData$flip", "checkMainAxis", "crossAxis", "checkCrossAxis", "fallbackPlacements", "specifiedFallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "detectOverflowOptions", "_objectWithoutPropertiesLoose", "_excluded2", "isBasePlacement", "placements", "overflow", "overflows", "overflowsData", "every", "_middlewareData$flip2", "_overflowsData$filter", "nextIndex", "nextPlacement", "resetPlacement", "sort", "a", "b", "_overflowsData$map$so", "acc", "getCrossAxis", "shift", "limiter", "_excluded4", "mainAxisCoord", "crossAxisCoord", "minSide", "maxSide", "limitedCoords", "limitShift", "rawOffset", "computedOffset", "len", "limitMin", "limitMax", "_middlewareData$offse", "_middlewareData$offse2", "isOriginSide", "getWindow", "node", "_node$ownerDocument", "ownerDocument", "defaultView", "window", "getComputedStyle$1", "getComputedStyle", "isNode", "Node", "getNodeName", "nodeName", "toLowerCase", "uaString", "getUAString", "uaData", "navigator", "userAgentData", "brands", "item", "brand", "version", "join", "userAgent", "isShadowRoot", "ShadowRoot", "OwnElement", "isOverflowElement", "overflowX", "overflowY", "display", "test", "isTableElement", "isContainingBlock", "isFirefox", "css", "backdropFilter", "WebkitBackdropFilter", "transform", "perspective", "willChange", "some", "contain", "isClientRectVisualViewportBased", "isLastTraversableNode", "round", "getCssDimensions", "parseFloat", "hasOffset", "offsetWidth", "offsetHeight", "shouldFallback", "fallback", "unwrapElement", "FALLBACK_SCALE", "domElement", "getBoundingClientRect", "Number", "isFinite", "includeScale", "isFixedStrategy", "_win$visualViewport", "_win$visualViewport2", "clientRect", "scale", "win", "addVisualOffsets", "visualViewport", "offsetLeft", "offsetTop", "offsetWin", "currentIFrame", "frameElement", "iframeScale", "iframeRect", "clientLeft", "paddingLeft", "clientTop", "paddingTop", "documentElement", "getNodeScroll", "scrollLeft", "scrollTop", "pageXOffset", "pageYOffset", "isOffsetParentAnElement", "scroll", "offsets", "offsetRect", "getWindowScrollBarX", "getDocumentRect", "html", "scrollWidth", "clientWidth", "scrollHeight", "clientHeight", "getParentNode", "result", "assignedSlot", "parentNode", "host", "getNearestOverflowAncestor", "getOverflowAncestors", "scrollableAncestor", "isBody", "getViewportRect", "visualViewportBased", "getInnerBoundingClientRect", "getClientRectFromClippingAncestor", "clippingAncestor", "mutableRect", "getClippingElementAncestors", "cache", "cachedResult", "get", "currentContainingBlockComputedStyle", "elementIsFixed", "position", "currentNode", "computedStyle", "containingBlock", "shouldIgnoreCurrentNode", "shouldDropCurrentNode", "ancestor", "set", "elementClippingAncestors", "_c", "clippingAncestors", "firstClippingAncestor", "clippingRect", "accRect", "getTrueOffsetParent", "polyfill", "getContainingBlock", "getRectRelativeToOffsetParent", "getOffsetParentFn", "getDimensionsFn", "getClientRects", "from", "autoUpdate", "update", "ancestorScroll", "_ancestorScroll", "ancestorResize", "elementResize", "animationFrame", "ancestors", "passive", "observer", "ResizeObserver", "observe", "frameId", "prevRefRect", "frameLoop", "nextRefRect", "requestAnimationFrame", "_observer", "disconnect", "cancelAnimationFrame", "Map", "mergedOptions", "platformWithCache", "computePosition$1", "setupTooltip", "cleanup", "attachToOptions", "_getResolvedAttachToOptions", "floatingUIOptions", "getFloatingUIOptions", "shouldCenter", "content", "shepherdElementComponent", "getElement", "classList", "add", "setPosition", "mergeTooltipConfig", "tourOptions", "merge", "destroyTooltip", "then", "floatingUIposition", "Promise", "resolve", "setTimeout", "focus", "preventScroll", "style", "dataset", "popperPlacement", "placeArrow", "arrowEl", "arrowX", "arrowY", "addArrow", "noop", "tar", "src", "k", "run", "blank_object", "create", "run_all", "fns", "is_function", "thing", "safe_not_equal", "is_empty", "obj", "append", "appendChild", "insert", "anchor", "insertBefore", "detach", "removeChild", "destroy_each", "iterations", "detaching", "createElement", "svg_element", "createElementNS", "text", "createTextNode", "space", "empty", "listen", "attr", "attribute", "removeAttribute", "getAttribute", "setAttribute", "set_attributes", "attributes", "descriptors", "getOwnPropertyDescriptors", "__proto__", "cssText", "children", "childNodes", "toggle_class", "toggle", "current_component", "set_current_component", "component", "get_current_component", "onMount", "$$", "on_mount", "afterUpdate", "after_update", "dirty_components", "binding_callbacks", "render_callbacks", "flush_callbacks", "resolved_promise", "update_scheduled", "schedule_update", "flush", "add_render_callback", "seen_callbacks", "Set", "flushidx", "saved_component", "pop", "callback", "has", "clear", "fragment", "before_update", "dirty", "p", "flush_render_callbacks", "filtered", "targets", "indexOf", "outroing", "outros", "group_outros", "check_outros", "transition_in", "block", "local", "delete", "transition_out", "o", "get_spread_update", "levels", "updates", "to_null_out", "accounted_for", "$$scope", "n", "create_component", "mount_component", "customElement", "m", "new_on_destroy", "on_destroy", "destroy_component", "make_dirty", "fill", "init", "instance", "create_fragment", "not_equal", "props", "append_styles", "parent_component", "bound", "on_disconnect", "callbacks", "skip_bound", "root", "ready", "ret", "hydrate", "nodes", "l", "intro", "SvelteComponent", "$destroy", "$on", "type", "$set", "$$props", "$$set", "button", "button_class_value", "action", "classes", "disabled", "label", "secondary", "getConfigOption", "option", "$$invalidate", "each_blocks", "create_if_block", "footer", "$", "buttons", "button_aria_label_value", "span", "cancelIcon", "handleCancelClick", "preventDefault", "cancel", "h3", "labelId", "title", "innerHTML", "$$value", "create_if_block_1", "enabled", "header", "div", "descriptionId", "show_if_2", "show_if_1", "show_if", "div_aria_describedby_value", "current", "KEY_TAB", "KEY_ESC", "LEFT_ARROW", "RIGHT_ARROW", "getClassesArray", "className", "classPrefix", "firstFocusableElement", "focusableElements", "lastFocusableElement", "dataStepId", "hasCancelIcon", "hasTitle", "id", "querySelectorAll", "updateDynamicClasses", "removeClasses", "addClasses", "oldClasses", "remove", "newClasses", "handleKeyDown", "keyCode", "shiftKey", "activeElement", "contains", "exitOnEsc", "keyboardNavigation", "back", "Step", "styles", "_resolvedAttachTo", "_setOptions", "complete", "destroy", "_updateStepTargetOnHide", "getTour", "hide", "modal", "hidden", "_resolveAttachToOptions", "show", "beforeShowPromise", "_show", "updateStepOptions", "getTarget", "_createTooltipContent", "ShepherdElement", "stepsContainer", "_scrollTo", "scrollToOptions", "scrollToHandler", "scrollIntoView", "_getClassOptions", "stepOptions", "defaultStepOptions", "stepClasses", "defaultStepOptionsClasses", "allClasses", "uniqClasses", "trim", "when", "_setupElements", "_setupModal", "setupForStep", "_styleTargetElementForStep", "scrollTo", "targetElement", "highlightClass", "canClickTarget", "cleanupSteps", "steps", "makeOverlayPath", "innerWidth", "w", "innerHeight", "h", "topLeft", "topRight", "bottomRight", "bottomLeft", "svg", "path", "_getScrollParent", "isHtmlElement", "isScrollable", "parentElement", "_getVisibleHeight", "scrollParent", "elementRect", "scrollRect", "scrollBottom", "openingProperties", "modalIsVisible", "rafId", "pathDefinition", "closeModalOpening", "_cleanupStepEventListeners", "positionModal", "modalOverlayOpeningPadding", "modalOverlayOpeningRadius", "useModalOverlay", "_styleForStep", "_preventModalBodyTouch", "_preventModalOverlayTouch", "stopPropagation", "_addStepEventListeners", "rafLoop", "Shepherd", "Tour", "defaultTourOptions", "addSteps", "events", "opts", "_setTourID", "addStep", "currentStep", "confirmCancel", "confirmCancelIsFunction", "cancelMessage", "confirmCancelMessage", "stopTour", "confirm", "_done", "getById", "find", "getCurrentStep", "isActive", "activeTour", "removeStep", "forward", "_updateStateBeforeShow", "shouldSkipStep", "showOn", "_skipStep", "previous", "focusedElBeforeOpen", "_setupActiveTour", "modalContainer", "ShepherdModal", "tourName", "isServerSide", "NoOp"]
}
