import "./chunk-WNKWOKNR.js";

// node_modules/shufflejs/dist/shuffle.esm.js
var tinyEmitter = { exports: {} };
function E() {
}
E.prototype = {
  on: function(name, callback, ctx) {
    var e = this.e || (this.e = {});
    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx
    });
    return this;
  },
  once: function(name, callback, ctx) {
    var self = this;
    function listener() {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },
  emit: function(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function(name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];
    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }
    liveEvents.length ? e[name] = liveEvents : delete e[name];
    return this;
  }
};
tinyEmitter.exports = E;
tinyEmitter.exports.TinyEmitter = E;
var arrayParallel = function parallel(fns, context, callback) {
  if (!callback) {
    if (typeof context === "function") {
      callback = context;
      context = null;
    } else {
      callback = noop;
    }
  }
  var pending = fns && fns.length;
  if (!pending)
    return callback(null, []);
  var finished = false;
  var results = new Array(pending);
  fns.forEach(context ? function(fn, i) {
    fn.call(context, maybeDone(i));
  } : function(fn, i) {
    fn(maybeDone(i));
  });
  function maybeDone(i) {
    return function(err, result) {
      if (finished)
        return;
      if (err) {
        callback(err, results);
        finished = true;
        return;
      }
      results[i] = result;
      if (!--pending)
        callback(null, results);
    };
  }
};
function noop() {
}
function getNumber(value2) {
  return parseFloat(value2) || 0;
}
var Point = class {
  /**
   * Represents a coordinate pair.
   * @param {number} [x=0] X.
   * @param {number} [y=0] Y.
   */
  constructor(x, y) {
    this.x = getNumber(x);
    this.y = getNumber(y);
  }
  /**
   * Whether two points are equal.
   * @param {Point} a Point A.
   * @param {Point} b Point B.
   * @return {boolean}
   */
  static equals(a, b) {
    return a.x === b.x && a.y === b.y;
  }
};
var Rect = class {
  /**
   * Class for representing rectangular regions.
   * https://github.com/google/closure-library/blob/master/closure/goog/math/rect.js
   * @param {number} x Left.
   * @param {number} y Top.
   * @param {number} w Width.
   * @param {number} h Height.
   * @param {number} id Identifier
   * @constructor
   */
  constructor(x, y, w, h, id2) {
    this.id = id2;
    this.left = x;
    this.top = y;
    this.width = w;
    this.height = h;
  }
  /**
   * Returns whether two rectangles intersect.
   * @param {Rect} a A Rectangle.
   * @param {Rect} b A Rectangle.
   * @return {boolean} Whether a and b intersect.
   */
  static intersects(a, b) {
    return a.left < b.left + b.width && b.left < a.left + a.width && a.top < b.top + b.height && b.top < a.top + a.height;
  }
};
var Classes = {
  BASE: "shuffle",
  SHUFFLE_ITEM: "shuffle-item",
  VISIBLE: "shuffle-item--visible",
  HIDDEN: "shuffle-item--hidden"
};
var id$1 = 0;
var ShuffleItem = class _ShuffleItem {
  constructor(element, isRTL) {
    id$1 += 1;
    this.id = id$1;
    this.element = element;
    this.isRTL = isRTL;
    this.isVisible = true;
    this.isHidden = false;
  }
  show() {
    this.isVisible = true;
    this.element.classList.remove(Classes.HIDDEN);
    this.element.classList.add(Classes.VISIBLE);
    this.element.removeAttribute("aria-hidden");
  }
  hide() {
    this.isVisible = false;
    this.element.classList.remove(Classes.VISIBLE);
    this.element.classList.add(Classes.HIDDEN);
    this.element.setAttribute("aria-hidden", true);
  }
  init() {
    this.addClasses([Classes.SHUFFLE_ITEM, Classes.VISIBLE]);
    this.applyCss(_ShuffleItem.Css.INITIAL);
    this.applyCss(this.isRTL ? _ShuffleItem.Css.DIRECTION.rtl : _ShuffleItem.Css.DIRECTION.ltr);
    this.scale = _ShuffleItem.Scale.VISIBLE;
    this.point = new Point();
  }
  addClasses(classes) {
    classes.forEach((className) => {
      this.element.classList.add(className);
    });
  }
  removeClasses(classes) {
    classes.forEach((className) => {
      this.element.classList.remove(className);
    });
  }
  applyCss(obj) {
    Object.keys(obj).forEach((key) => {
      this.element.style[key] = obj[key];
    });
  }
  dispose() {
    this.removeClasses([Classes.HIDDEN, Classes.VISIBLE, Classes.SHUFFLE_ITEM]);
    this.element.removeAttribute("style");
    this.element = null;
  }
};
ShuffleItem.Css = {
  INITIAL: {
    position: "absolute",
    top: 0,
    visibility: "visible",
    willChange: "transform"
  },
  DIRECTION: {
    ltr: {
      left: 0
    },
    rtl: {
      right: 0
    }
  },
  VISIBLE: {
    before: {
      opacity: 1,
      visibility: "visible"
    },
    after: {
      transitionDelay: ""
    }
  },
  HIDDEN: {
    before: {
      opacity: 0
    },
    after: {
      visibility: "hidden",
      transitionDelay: ""
    }
  }
};
ShuffleItem.Scale = {
  VISIBLE: 1,
  HIDDEN: 1e-3
};
var value = null;
var testComputedSize = () => {
  if (value !== null) {
    return value;
  }
  const element = document.body || document.documentElement;
  const e = document.createElement("div");
  e.style.cssText = "width:10px;padding:2px;box-sizing:border-box;";
  element.appendChild(e);
  const {
    width
  } = window.getComputedStyle(e, null);
  value = Math.round(getNumber(width)) === 10;
  element.removeChild(e);
  return value;
};
function getNumberStyle(element, style) {
  let styles = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : window.getComputedStyle(element, null);
  let value2 = getNumber(styles[style]);
  if (!testComputedSize() && style === "width") {
    value2 += getNumber(styles.paddingLeft) + getNumber(styles.paddingRight) + getNumber(styles.borderLeftWidth) + getNumber(styles.borderRightWidth);
  } else if (!testComputedSize() && style === "height") {
    value2 += getNumber(styles.paddingTop) + getNumber(styles.paddingBottom) + getNumber(styles.borderTopWidth) + getNumber(styles.borderBottomWidth);
  }
  return value2;
}
function randomize(array) {
  let n = array.length;
  while (n) {
    n -= 1;
    const i = Math.floor(Math.random() * (n + 1));
    const temp = array[i];
    array[i] = array[n];
    array[n] = temp;
  }
  return array;
}
var defaults = {
  // Use array.reverse() to reverse the results
  reverse: false,
  // Sorting function
  by: null,
  // Custom sort function
  compare: null,
  // If true, this will skip the sorting and return a randomized order in the array
  randomize: false,
  // Determines which property of each item in the array is passed to the
  // sorting method.
  key: "element"
};
function sorter(arr, options) {
  const opts = {
    ...defaults,
    ...options
  };
  const original = Array.from(arr);
  let revert = false;
  if (!arr.length) {
    return [];
  }
  if (opts.randomize) {
    return randomize(arr);
  }
  if (typeof opts.by === "function") {
    arr.sort((a, b) => {
      if (revert) {
        return 0;
      }
      const valA = opts.by(a[opts.key]);
      const valB = opts.by(b[opts.key]);
      if (valA === void 0 && valB === void 0) {
        revert = true;
        return 0;
      }
      if (valA < valB || valA === "sortFirst" || valB === "sortLast") {
        return -1;
      }
      if (valA > valB || valA === "sortLast" || valB === "sortFirst") {
        return 1;
      }
      return 0;
    });
  } else if (typeof opts.compare === "function") {
    arr.sort(opts.compare);
  }
  if (revert) {
    return original;
  }
  if (opts.reverse) {
    arr.reverse();
  }
  return arr;
}
var transitions = {};
var eventName = "transitionend";
var count = 0;
function uniqueId() {
  count += 1;
  return eventName + count;
}
function cancelTransitionEnd(id2) {
  if (transitions[id2]) {
    transitions[id2].element.removeEventListener(eventName, transitions[id2].listener);
    transitions[id2] = null;
    return true;
  }
  return false;
}
function onTransitionEnd(element, callback) {
  const id2 = uniqueId();
  const listener = (evt) => {
    if (evt.currentTarget === evt.target) {
      cancelTransitionEnd(id2);
      callback(evt);
    }
  };
  element.addEventListener(eventName, listener);
  transitions[id2] = {
    element,
    listener
  };
  return id2;
}
function arrayMax(array) {
  return Math.max(...array);
}
function arrayMin(array) {
  return Math.min(...array);
}
function getColumnSpan(itemWidth, columnWidth, columns, threshold) {
  let columnSpan = itemWidth / columnWidth;
  if (Math.abs(Math.round(columnSpan) - columnSpan) < threshold) {
    columnSpan = Math.round(columnSpan);
  }
  return Math.min(Math.ceil(columnSpan), columns);
}
function getAvailablePositions(positions, columnSpan, columns) {
  if (columnSpan === 1) {
    return positions;
  }
  const available = [];
  for (let i = 0; i <= columns - columnSpan; i++) {
    available.push(arrayMax(positions.slice(i, i + columnSpan)));
  }
  return available;
}
function getShortColumn(positions, buffer) {
  const minPosition = arrayMin(positions);
  for (let i = 0, len = positions.length; i < len; i++) {
    if (positions[i] >= minPosition - buffer && positions[i] <= minPosition + buffer) {
      return i;
    }
  }
  return 0;
}
function getItemPosition(_ref) {
  let {
    itemSize,
    positions,
    gridSize,
    total,
    threshold,
    buffer
  } = _ref;
  const span = getColumnSpan(itemSize.width, gridSize, total, threshold);
  const setY = getAvailablePositions(positions, span, total);
  const shortColumnIndex = getShortColumn(setY, buffer);
  const point = new Point(gridSize * shortColumnIndex, setY[shortColumnIndex]);
  const setHeight = setY[shortColumnIndex] + itemSize.height;
  for (let i = 0; i < span; i++) {
    positions[shortColumnIndex + i] = setHeight;
  }
  return point;
}
function getCenteredPositions(itemRects, containerWidth) {
  const rowMap = {};
  itemRects.forEach((itemRect) => {
    if (rowMap[itemRect.top]) {
      rowMap[itemRect.top].push(itemRect);
    } else {
      rowMap[itemRect.top] = [itemRect];
    }
  });
  let rects = [];
  const rows = [];
  const centeredRows = [];
  Object.keys(rowMap).forEach((key) => {
    const itemRects2 = rowMap[key];
    rows.push(itemRects2);
    const lastItem = itemRects2[itemRects2.length - 1];
    const end = lastItem.left + lastItem.width;
    const offset = Math.round((containerWidth - end) / 2);
    let finalRects = itemRects2;
    let canMove = false;
    if (offset > 0) {
      const newRects = [];
      canMove = itemRects2.every((r) => {
        const newRect = new Rect(r.left + offset, r.top, r.width, r.height, r.id);
        const noOverlap = !rects.some((r2) => Rect.intersects(newRect, r2));
        newRects.push(newRect);
        return noOverlap;
      });
      if (canMove) {
        finalRects = newRects;
      }
    }
    if (!canMove) {
      let intersectingRect;
      const hasOverlap = itemRects2.some((itemRect) => rects.some((r) => {
        const intersects = Rect.intersects(itemRect, r);
        if (intersects) {
          intersectingRect = r;
        }
        return intersects;
      }));
      if (hasOverlap) {
        const rowIndex = centeredRows.findIndex((items) => items.includes(intersectingRect));
        centeredRows.splice(rowIndex, 1, rows[rowIndex]);
      }
    }
    rects = rects.concat(finalRects);
    centeredRows.push(finalRects);
  });
  return centeredRows.flat().sort((a, b) => a.id - b.id).map((itemRect) => new Point(itemRect.left, itemRect.top));
}
function hyphenate(str) {
  return str.replace(/([A-Z])/g, (str2, m1) => `-${m1.toLowerCase()}`);
}
function arrayUnique(x) {
  return Array.from(new Set(x));
}
var id = 0;
var Shuffle = class _Shuffle extends tinyEmitter.exports {
  /**
   * Categorize, sort, and filter a responsive grid of items.
   *
   * @param {Element} element An element which is the parent container for the grid items.
   * @param {Object} [options=Shuffle.options] Options object.
   * @constructor
   */
  constructor(element) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    this.options = {
      ..._Shuffle.options,
      ...options
    };
    this.lastSort = {};
    this.group = _Shuffle.ALL_ITEMS;
    this.lastFilter = _Shuffle.ALL_ITEMS;
    this.isEnabled = true;
    this.isDestroyed = false;
    this.isInitialized = false;
    this._transitions = [];
    this.isTransitioning = false;
    this._queue = [];
    const el = this._getElementOption(element);
    if (!el) {
      throw new TypeError("Shuffle needs to be initialized with an element.");
    }
    this.element = el;
    this.id = `shuffle_${id}`;
    id += 1;
    this._init();
    this.isInitialized = true;
  }
  _init() {
    this.items = this._getItems();
    this.sortedItems = this.items;
    this.options.sizer = this._getElementOption(this.options.sizer);
    this.element.classList.add(_Shuffle.Classes.BASE);
    this._initItems(this.items);
    if (document.readyState !== "complete") {
      const layout = this.layout.bind(this);
      window.addEventListener("load", function onLoad() {
        window.removeEventListener("load", onLoad);
        layout();
      });
    }
    const containerCss = window.getComputedStyle(this.element, null);
    const containerWidth = _Shuffle.getSize(this.element).width;
    this._validateStyles(containerCss);
    this._setColumns(containerWidth);
    this.filter(this.options.group, this.options.initialSort);
    this._rafId = null;
    if ("ResizeObserver" in window) {
      this._resizeObserver = new ResizeObserver(this._handleResizeCallback.bind(this));
      this._resizeObserver.observe(this.element);
    }
    this.element.offsetWidth;
    this.setItemTransitions(this.items);
    this.element.style.transition = `height ${this.options.speed}ms ${this.options.easing}`;
  }
  /**
   * Retrieve an element from an option.
   * @param {string|jQuery|Element} option The option to check.
   * @return {?Element} The plain element or null.
   * @private
   */
  _getElementOption(option) {
    if (typeof option === "string") {
      return this.element.querySelector(option);
    }
    if (option && option.nodeType && option.nodeType === 1) {
      return option;
    }
    if (option && option.jquery) {
      return option[0];
    }
    return null;
  }
  /**
   * Ensures the shuffle container has the css styles it needs applied to it.
   * @param {Object} styles Key value pairs for position and overflow.
   * @private
   */
  _validateStyles(styles) {
    if (styles.position === "static") {
      this.element.style.position = "relative";
    }
    if (styles.overflow !== "hidden") {
      this.element.style.overflow = "hidden";
    }
  }
  /**
   * Filter the elements by a category.
   * @param {string|string[]|function(Element):boolean} [category] Category to
   *     filter by. If it's given, the last category will be used to filter the items.
   * @param {Array} [collection] Optionally filter a collection. Defaults to
   *     all the items.
   * @return {{visible: ShuffleItem[], hidden: ShuffleItem[]}}
   * @private
   */
  _filter() {
    let category = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.lastFilter;
    let collection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.items;
    const set = this._getFilteredSets(category, collection);
    this._toggleFilterClasses(set);
    this.lastFilter = category;
    if (typeof category === "string") {
      this.group = category;
    }
    return set;
  }
  /**
   * Returns an object containing the visible and hidden elements.
   * @param {string|string[]|function(Element):boolean} category Category or function to filter by.
   * @param {ShuffleItem[]} items A collection of items to filter.
   * @return {{visible: ShuffleItem[], hidden: ShuffleItem[]}}
   * @private
   */
  _getFilteredSets(category, items) {
    let visible = [];
    const hidden = [];
    if (category === _Shuffle.ALL_ITEMS) {
      visible = items;
    } else {
      items.forEach((item) => {
        if (this._doesPassFilter(category, item.element)) {
          visible.push(item);
        } else {
          hidden.push(item);
        }
      });
    }
    return {
      visible,
      hidden
    };
  }
  /**
   * Test an item to see if it passes a category.
   * @param {string|string[]|function():boolean} category Category or function to filter by.
   * @param {Element} element An element to test.
   * @return {boolean} Whether it passes the category/filter.
   * @private
   */
  _doesPassFilter(category, element) {
    if (typeof category === "function") {
      return category.call(element, element, this);
    }
    const attr = element.dataset[_Shuffle.FILTER_ATTRIBUTE_KEY];
    const keys = this.options.delimiter ? attr.split(this.options.delimiter) : JSON.parse(attr);
    function testCategory(category2) {
      return keys.includes(category2);
    }
    if (Array.isArray(category)) {
      if (this.options.filterMode === _Shuffle.FilterMode.ANY) {
        return category.some(testCategory);
      }
      return category.every(testCategory);
    }
    return keys.includes(category);
  }
  /**
   * Toggles the visible and hidden class names.
   * @param {{visible, hidden}} Object with visible and hidden arrays.
   * @private
   */
  _toggleFilterClasses(_ref) {
    let {
      visible,
      hidden
    } = _ref;
    visible.forEach((item) => {
      item.show();
    });
    hidden.forEach((item) => {
      item.hide();
    });
  }
  /**
   * Set the initial css for each item
   * @param {ShuffleItem[]} items Set to initialize.
   * @private
   */
  _initItems(items) {
    items.forEach((item) => {
      item.init();
    });
  }
  /**
   * Remove element reference and styles.
   * @param {ShuffleItem[]} items Set to dispose.
   * @private
   */
  _disposeItems(items) {
    items.forEach((item) => {
      item.dispose();
    });
  }
  /**
   * Updates the visible item count.
   * @private
   */
  _updateItemCount() {
    this.visibleItems = this._getFilteredItems().length;
  }
  /**
   * Sets css transform transition on a group of elements. This is not executed
   * at the same time as `item.init` so that transitions don't occur upon
   * initialization of a new Shuffle instance.
   * @param {ShuffleItem[]} items Shuffle items to set transitions on.
   * @protected
   */
  setItemTransitions(items) {
    const {
      speed,
      easing
    } = this.options;
    const positionProps = this.options.useTransforms ? ["transform"] : ["top", "left"];
    const cssProps = Object.keys(ShuffleItem.Css.HIDDEN.before).map((k) => hyphenate(k));
    const properties = positionProps.concat(cssProps).join();
    items.forEach((item) => {
      item.element.style.transitionDuration = `${speed}ms`;
      item.element.style.transitionTimingFunction = easing;
      item.element.style.transitionProperty = properties;
    });
  }
  _getItems() {
    return Array.from(this.element.children).filter((el) => el.matches(this.options.itemSelector)).map((el) => new ShuffleItem(el, this.options.isRTL));
  }
  /**
   * Combine the current items array with a new one and sort it by DOM order.
   * @param {ShuffleItem[]} items Items to track.
   * @return {ShuffleItem[]}
   */
  _mergeNewItems(items) {
    const children = Array.from(this.element.children);
    return sorter(this.items.concat(items), {
      by(element) {
        return children.indexOf(element);
      }
    });
  }
  _getFilteredItems() {
    return this.items.filter((item) => item.isVisible);
  }
  _getConcealedItems() {
    return this.items.filter((item) => !item.isVisible);
  }
  /**
   * Returns the column size, based on column width and sizer options.
   * @param {number} containerWidth Size of the parent container.
   * @param {number} gutterSize Size of the gutters.
   * @return {number}
   * @private
   */
  _getColumnSize(containerWidth, gutterSize) {
    let size;
    if (typeof this.options.columnWidth === "function") {
      size = this.options.columnWidth(containerWidth);
    } else if (this.options.sizer) {
      size = _Shuffle.getSize(this.options.sizer).width;
    } else if (this.options.columnWidth) {
      size = this.options.columnWidth;
    } else if (this.items.length > 0) {
      size = _Shuffle.getSize(this.items[0].element, true).width;
    } else {
      size = containerWidth;
    }
    if (size === 0) {
      size = containerWidth;
    }
    return size + gutterSize;
  }
  /**
   * Returns the gutter size, based on gutter width and sizer options.
   * @param {number} containerWidth Size of the parent container.
   * @return {number}
   * @private
   */
  _getGutterSize(containerWidth) {
    let size;
    if (typeof this.options.gutterWidth === "function") {
      size = this.options.gutterWidth(containerWidth);
    } else if (this.options.sizer) {
      size = getNumberStyle(this.options.sizer, "marginLeft");
    } else {
      size = this.options.gutterWidth;
    }
    return size;
  }
  /**
   * Calculate the number of columns to be used. Gets css if using sizer element.
   * @param {number} [containerWidth] Optionally specify a container width if
   *    it's already available.
   */
  _setColumns() {
    let containerWidth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _Shuffle.getSize(this.element).width;
    const gutter = this._getGutterSize(containerWidth);
    const columnWidth = this._getColumnSize(containerWidth, gutter);
    let calculatedColumns = (containerWidth + gutter) / columnWidth;
    if (Math.abs(Math.round(calculatedColumns) - calculatedColumns) < this.options.columnThreshold) {
      calculatedColumns = Math.round(calculatedColumns);
    }
    this.cols = Math.max(Math.floor(calculatedColumns || 0), 1);
    this.containerWidth = containerWidth;
    this.colWidth = columnWidth;
  }
  /**
   * Adjust the height of the grid
   */
  _setContainerSize() {
    this.element.style.height = `${this._getContainerSize()}px`;
  }
  /**
   * Based on the column heights, it returns the biggest one.
   * @return {number}
   * @private
   */
  _getContainerSize() {
    return arrayMax(this.positions);
  }
  /**
   * Get the clamped stagger amount.
   * @param {number} index Index of the item to be staggered.
   * @return {number}
   */
  _getStaggerAmount(index) {
    return Math.min(index * this.options.staggerAmount, this.options.staggerAmountMax);
  }
  /**
   * Emit an event from this instance.
   * @param {string} name Event name.
   * @param {Object} [data={}] Optional object data.
   */
  _dispatch(name) {
    let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.isDestroyed) {
      return;
    }
    data.shuffle = this;
    this.emit(name, data);
  }
  /**
   * Zeros out the y columns array, which is used to determine item placement.
   * @private
   */
  _resetCols() {
    let i = this.cols;
    this.positions = [];
    while (i) {
      i -= 1;
      this.positions.push(0);
    }
  }
  /**
   * Loops through each item that should be shown and calculates the x, y position.
   * @param {ShuffleItem[]} items Array of items that will be shown/layed
   *     out in order in their array.
   */
  _layout(items) {
    const itemPositions = this._getNextPositions(items);
    let count2 = 0;
    items.forEach((item, i) => {
      function callback() {
        item.applyCss(ShuffleItem.Css.VISIBLE.after);
      }
      if (Point.equals(item.point, itemPositions[i]) && !item.isHidden) {
        item.applyCss(ShuffleItem.Css.VISIBLE.before);
        callback();
        return;
      }
      item.point = itemPositions[i];
      item.scale = ShuffleItem.Scale.VISIBLE;
      item.isHidden = false;
      const styles = this.getStylesForTransition(item, ShuffleItem.Css.VISIBLE.before);
      styles.transitionDelay = `${this._getStaggerAmount(count2)}ms`;
      this._queue.push({
        item,
        styles,
        callback
      });
      count2 += 1;
    });
  }
  /**
   * Return an array of Point instances representing the future positions of
   * each item.
   * @param {ShuffleItem[]} items Array of sorted shuffle items.
   * @return {Point[]}
   * @private
   */
  _getNextPositions(items) {
    if (this.options.isCentered) {
      const itemsData = items.map((item, i) => {
        const itemSize = _Shuffle.getSize(item.element, true);
        const point = this._getItemPosition(itemSize);
        return new Rect(point.x, point.y, itemSize.width, itemSize.height, i);
      });
      return this.getTransformedPositions(itemsData, this.containerWidth);
    }
    return items.map((item) => this._getItemPosition(_Shuffle.getSize(item.element, true)));
  }
  /**
   * Determine the location of the next item, based on its size.
   * @param {{width: number, height: number}} itemSize Object with width and height.
   * @return {Point}
   * @private
   */
  _getItemPosition(itemSize) {
    return getItemPosition({
      itemSize,
      positions: this.positions,
      gridSize: this.colWidth,
      total: this.cols,
      threshold: this.options.columnThreshold,
      buffer: this.options.buffer
    });
  }
  /**
   * Mutate positions before they're applied.
   * @param {Rect[]} itemRects Item data objects.
   * @param {number} containerWidth Width of the containing element.
   * @return {Point[]}
   * @protected
   */
  getTransformedPositions(itemRects, containerWidth) {
    return getCenteredPositions(itemRects, containerWidth);
  }
  /**
   * Hides the elements that don't match our filter.
   * @param {ShuffleItem[]} collection Collection to shrink.
   * @private
   */
  _shrink() {
    let collection = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._getConcealedItems();
    let count2 = 0;
    collection.forEach((item) => {
      function callback() {
        item.applyCss(ShuffleItem.Css.HIDDEN.after);
      }
      if (item.isHidden) {
        item.applyCss(ShuffleItem.Css.HIDDEN.before);
        callback();
        return;
      }
      item.scale = ShuffleItem.Scale.HIDDEN;
      item.isHidden = true;
      const styles = this.getStylesForTransition(item, ShuffleItem.Css.HIDDEN.before);
      styles.transitionDelay = `${this._getStaggerAmount(count2)}ms`;
      this._queue.push({
        item,
        styles,
        callback
      });
      count2 += 1;
    });
  }
  /**
   * Resize handler.
   * @param {ResizeObserverEntry[]} entries
   */
  _handleResizeCallback(entries) {
    if (!this.isEnabled || this.isDestroyed) {
      return;
    }
    for (const entry of entries) {
      if (Math.round(entry.contentRect.width) !== Math.round(this.containerWidth)) {
        cancelAnimationFrame(this._rafId);
        this._rafId = requestAnimationFrame(this.update.bind(this));
      }
    }
  }
  /**
   * Returns styles which will be applied to the an item for a transition.
   * @param {ShuffleItem} item Item to get styles for. Should have updated
   *   scale and point properties.
   * @param {Object} styleObject Extra styles that will be used in the transition.
   * @return {!Object} Transforms for transitions, left/top for animate.
   * @protected
   */
  getStylesForTransition(item, styleObject) {
    const styles = {
      ...styleObject
    };
    if (this.options.useTransforms) {
      const sign = this.options.isRTL ? "-" : "";
      const x = this.options.roundTransforms ? Math.round(item.point.x) : item.point.x;
      const y = this.options.roundTransforms ? Math.round(item.point.y) : item.point.y;
      styles.transform = `translate(${sign}${x}px, ${y}px) scale(${item.scale})`;
    } else {
      if (this.options.isRTL) {
        styles.right = `${item.point.x}px`;
      } else {
        styles.left = `${item.point.x}px`;
      }
      styles.top = `${item.point.y}px`;
    }
    return styles;
  }
  /**
   * Listen for the transition end on an element and execute the itemCallback
   * when it finishes.
   * @param {Element} element Element to listen on.
   * @param {function} itemCallback Callback for the item.
   * @param {function} done Callback to notify `parallel` that this one is done.
   */
  _whenTransitionDone(element, itemCallback, done) {
    const id2 = onTransitionEnd(element, (evt) => {
      itemCallback();
      done(null, evt);
    });
    this._transitions.push(id2);
  }
  /**
   * Return a function which will set CSS styles and call the `done` function
   * when (if) the transition finishes.
   * @param {Object} opts Transition object.
   * @return {function} A function to be called with a `done` function.
   */
  _getTransitionFunction(opts) {
    return (done) => {
      opts.item.applyCss(opts.styles);
      this._whenTransitionDone(opts.item.element, opts.callback, done);
    };
  }
  /**
   * Execute the styles gathered in the style queue. This applies styles to elements,
   * triggering transitions.
   * @private
   */
  _processQueue() {
    if (this.isTransitioning) {
      this._cancelMovement();
    }
    const hasSpeed = this.options.speed > 0;
    const hasQueue = this._queue.length > 0;
    if (hasQueue && hasSpeed && this.isInitialized) {
      this._startTransitions(this._queue);
    } else if (hasQueue) {
      this._styleImmediately(this._queue);
      this._dispatch(_Shuffle.EventType.LAYOUT);
    } else {
      this._dispatch(_Shuffle.EventType.LAYOUT);
    }
    this._queue.length = 0;
  }
  /**
   * Wait for each transition to finish, the emit the layout event.
   * @param {Object[]} transitions Array of transition objects.
   */
  _startTransitions(transitions2) {
    this.isTransitioning = true;
    const callbacks = transitions2.map((obj) => this._getTransitionFunction(obj));
    arrayParallel(callbacks, this._movementFinished.bind(this));
  }
  _cancelMovement() {
    this._transitions.forEach(cancelTransitionEnd);
    this._transitions.length = 0;
    this.isTransitioning = false;
  }
  /**
   * Apply styles without a transition.
   * @param {Object[]} objects Array of transition objects.
   * @private
   */
  _styleImmediately(objects) {
    if (objects.length) {
      const elements = objects.map((obj) => obj.item.element);
      _Shuffle._skipTransitions(elements, () => {
        objects.forEach((obj) => {
          obj.item.applyCss(obj.styles);
          obj.callback();
        });
      });
    }
  }
  _movementFinished() {
    this._transitions.length = 0;
    this.isTransitioning = false;
    this._dispatch(_Shuffle.EventType.LAYOUT);
  }
  /**
   * The magic. This is what makes the plugin 'shuffle'
   * @param {string|string[]|function(Element):boolean} [category] Category to filter by.
   *     Can be a function, string, or array of strings.
   * @param {SortOptions} [sortOptions] A sort object which can sort the visible set
   */
  filter(category, sortOptions) {
    if (!this.isEnabled) {
      return;
    }
    if (!category || category && category.length === 0) {
      category = _Shuffle.ALL_ITEMS;
    }
    this._filter(category);
    this._shrink();
    this._updateItemCount();
    this.sort(sortOptions);
  }
  /**
   * Gets the visible elements, sorts them, and passes them to layout.
   * @param {SortOptions} [sortOptions] The options object to pass to `sorter`.
   */
  sort() {
    let sortOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.lastSort;
    if (!this.isEnabled) {
      return;
    }
    this._resetCols();
    const items = sorter(this._getFilteredItems(), sortOptions);
    this.sortedItems = items;
    this._layout(items);
    this._processQueue();
    this._setContainerSize();
    this.lastSort = sortOptions;
  }
  /**
   * Reposition everything.
   * @param {object} options options object
   * @param {boolean} [options.recalculateSizes=true] Whether to calculate column, gutter, and container widths again.
   * @param {boolean} [options.force=false] By default, `update` does nothing if the instance is disabled. Setting this
   *    to true forces the update to happen regardless.
   */
  update() {
    let {
      recalculateSizes = true,
      force = false
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.isEnabled || force) {
      if (recalculateSizes) {
        this._setColumns();
      }
      this.sort();
    }
  }
  /**
   * Use this instead of `update()` if you don't need the columns and gutters updated
   * Maybe an image inside `shuffle` loaded (and now has a height), which means calculations
   * could be off.
   */
  layout() {
    this.update({
      recalculateSizes: true
    });
  }
  /**
   * New items have been appended to shuffle. Mix them in with the current
   * filter or sort status.
   * @param {Element[]} newItems Collection of new items.
   */
  add(newItems) {
    const items = arrayUnique(newItems).map((el) => new ShuffleItem(el, this.options.isRTL));
    this._initItems(items);
    this._resetCols();
    const allItems = this._mergeNewItems(items);
    const sortedItems = sorter(allItems, this.lastSort);
    const allSortedItemsSet = this._filter(this.lastFilter, sortedItems);
    const isNewItem = (item) => items.includes(item);
    const applyHiddenState = (item) => {
      item.scale = ShuffleItem.Scale.HIDDEN;
      item.isHidden = true;
      item.applyCss(ShuffleItem.Css.HIDDEN.before);
      item.applyCss(ShuffleItem.Css.HIDDEN.after);
    };
    const itemPositions = this._getNextPositions(allSortedItemsSet.visible);
    allSortedItemsSet.visible.forEach((item, i) => {
      if (isNewItem(item)) {
        item.point = itemPositions[i];
        applyHiddenState(item);
        item.applyCss(this.getStylesForTransition(item, {}));
      }
    });
    allSortedItemsSet.hidden.forEach((item) => {
      if (isNewItem(item)) {
        applyHiddenState(item);
      }
    });
    this.element.offsetWidth;
    this.setItemTransitions(items);
    this.items = this._mergeNewItems(items);
    this.filter(this.lastFilter);
  }
  /**
   * Disables shuffle from updating dimensions and layout on resize
   */
  disable() {
    this.isEnabled = false;
  }
  /**
   * Enables shuffle again
   * @param {boolean} [isUpdateLayout=true] if undefined, shuffle will update columns and gutters
   */
  enable() {
    let isUpdateLayout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    this.isEnabled = true;
    if (isUpdateLayout) {
      this.update();
    }
  }
  /**
   * Remove 1 or more shuffle items.
   * @param {Element[]} elements An array containing one or more
   *     elements in shuffle
   * @return {Shuffle} The shuffle instance.
   */
  remove(elements) {
    if (!elements.length) {
      return;
    }
    const collection = arrayUnique(elements);
    const oldItems = collection.map((element) => this.getItemByElement(element)).filter((item) => !!item);
    const handleLayout = () => {
      this._disposeItems(oldItems);
      collection.forEach((element) => {
        element.parentNode.removeChild(element);
      });
      this._dispatch(_Shuffle.EventType.REMOVED, {
        collection
      });
    };
    this._toggleFilterClasses({
      visible: [],
      hidden: oldItems
    });
    this._shrink(oldItems);
    this.sort();
    this.items = this.items.filter((item) => !oldItems.includes(item));
    this._updateItemCount();
    this.once(_Shuffle.EventType.LAYOUT, handleLayout);
  }
  /**
   * Retrieve a shuffle item by its element.
   * @param {Element} element Element to look for.
   * @return {?ShuffleItem} A shuffle item or undefined if it's not found.
   */
  getItemByElement(element) {
    return this.items.find((item) => item.element === element);
  }
  /**
   * Dump the elements currently stored and reinitialize all child elements which
   * match the `itemSelector`.
   */
  resetItems() {
    this._disposeItems(this.items);
    this.isInitialized = false;
    this.items = this._getItems();
    this._initItems(this.items);
    this.once(_Shuffle.EventType.LAYOUT, () => {
      this.setItemTransitions(this.items);
      this.isInitialized = true;
    });
    this.filter(this.lastFilter);
  }
  /**
   * Destroys shuffle, removes events, styles, and classes
   */
  destroy() {
    this._cancelMovement();
    if (this._resizeObserver) {
      this._resizeObserver.unobserve(this.element);
      this._resizeObserver = null;
    }
    this.element.classList.remove("shuffle");
    this.element.removeAttribute("style");
    this._disposeItems(this.items);
    this.items.length = 0;
    this.sortedItems.length = 0;
    this._transitions.length = 0;
    this.options.sizer = null;
    this.element = null;
    this.isDestroyed = true;
    this.isEnabled = false;
  }
  /**
   * Returns the outer width of an element, optionally including its margins.
   *
   * There are a few different methods for getting the width of an element, none of
   * which work perfectly for all Shuffle's use cases.
   *
   * 1. getBoundingClientRect() `left` and `right` properties.
   *   - Accounts for transform scaled elements, making it useless for Shuffle
   *   elements which have shrunk.
   * 2. The `offsetWidth` property.
   *   - This value stays the same regardless of the elements transform property,
   *   however, it does not return subpixel values.
   * 3. getComputedStyle()
   *   - This works great Chrome, Firefox, Safari, but IE<=11 does not include
   *   padding and border when box-sizing: border-box is set, requiring a feature
   *   test and extra work to add the padding back for IE and other browsers which
   *   follow the W3C spec here.
   *
   * @param {Element} element The element.
   * @param {boolean} [includeMargins=false] Whether to include margins.
   * @return {{width: number, height: number}} The width and height.
   */
  static getSize(element) {
    let includeMargins = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const styles = window.getComputedStyle(element, null);
    let width = getNumberStyle(element, "width", styles);
    let height = getNumberStyle(element, "height", styles);
    if (includeMargins) {
      const marginLeft = getNumberStyle(element, "marginLeft", styles);
      const marginRight = getNumberStyle(element, "marginRight", styles);
      const marginTop = getNumberStyle(element, "marginTop", styles);
      const marginBottom = getNumberStyle(element, "marginBottom", styles);
      width += marginLeft + marginRight;
      height += marginTop + marginBottom;
    }
    return {
      width,
      height
    };
  }
  /**
   * Change a property or execute a function which will not have a transition
   * @param {Element[]} elements DOM elements that won't be transitioned.
   * @param {function} callback A function which will be called while transition
   *     is set to 0ms.
   * @private
   */
  static _skipTransitions(elements, callback) {
    const zero = "0ms";
    const data = elements.map((element) => {
      const {
        style
      } = element;
      const duration = style.transitionDuration;
      const delay = style.transitionDelay;
      style.transitionDuration = zero;
      style.transitionDelay = zero;
      return {
        duration,
        delay
      };
    });
    callback();
    elements[0].offsetWidth;
    elements.forEach((element, i) => {
      element.style.transitionDuration = data[i].duration;
      element.style.transitionDelay = data[i].delay;
    });
  }
};
Shuffle.ShuffleItem = ShuffleItem;
Shuffle.ALL_ITEMS = "all";
Shuffle.FILTER_ATTRIBUTE_KEY = "groups";
Shuffle.EventType = {
  LAYOUT: "shuffle:layout",
  REMOVED: "shuffle:removed"
};
Shuffle.Classes = Classes;
Shuffle.FilterMode = {
  ANY: "any",
  ALL: "all"
};
Shuffle.options = {
  // Initial filter group.
  group: Shuffle.ALL_ITEMS,
  // Transition/animation speed (milliseconds).
  speed: 250,
  // CSS easing function to use.
  easing: "cubic-bezier(0.4, 0.0, 0.2, 1)",
  // e.g. '.picture-item'.
  itemSelector: "*",
  // Element or selector string. Use an element to determine the size of columns
  // and gutters.
  sizer: null,
  // A static number or function that tells the plugin how wide the gutters
  // between columns are (in pixels).
  gutterWidth: 0,
  // A static number or function that returns a number which tells the plugin
  // how wide the columns are (in pixels).
  columnWidth: 0,
  // If your group is not json, and is comma delimited, you could set delimiter
  // to ','.
  delimiter: null,
  // Useful for percentage based heights when they might not always be exactly
  // the same (in pixels).
  buffer: 0,
  // Reading the width of elements isn't precise enough and can cause columns to
  // jump between values.
  columnThreshold: 0.01,
  // Shuffle can be initialized with a sort object. It is the same object
  // given to the sort method.
  initialSort: null,
  // Transition delay offset for each item in milliseconds.
  staggerAmount: 15,
  // Maximum stagger delay in milliseconds.
  staggerAmountMax: 150,
  // Whether to use transforms or absolute positioning.
  useTransforms: true,
  // Affects using an array with filter. e.g. `filter(['one', 'two'])`. With "any",
  // the element passes the test if any of its groups are in the array. With "all",
  // the element only passes if all groups are in the array.
  // Note, this has no effect if you supply a custom filter function.
  filterMode: Shuffle.FilterMode.ANY,
  // Attempt to center grid items in each row.
  isCentered: false,
  // Attempt to align grid items to right.
  isRTL: false,
  // Whether to round pixel values used in translate(x, y). This usually avoids
  // blurriness.
  roundTransforms: true
};
Shuffle.Point = Point;
Shuffle.Rect = Rect;
Shuffle.__sorter = sorter;
Shuffle.__getColumnSpan = getColumnSpan;
Shuffle.__getAvailablePositions = getAvailablePositions;
Shuffle.__getShortColumn = getShortColumn;
Shuffle.__getCenteredPositions = getCenteredPositions;
export {
  Shuffle as default
};
//# sourceMappingURL=shufflejs.js.map
